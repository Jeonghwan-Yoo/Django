파이썬
쉽고 간결함, 문법의 알관성, 빠르게 개발할 수 있는 생산성.
다양한 기능을 제공해주는 라이브러리, C언어와의 접착성, 콜백함수, 람다함수, 이터레이터, 제너레이터 등.
스크립트가 갖는 태생적 한계, 인터프리터당 1개의 쓰레드만 허용하는 GIL(Global Interpreter Lock)으로 단점이 있지만
파이썬 토네이도 프레임워크를 사용해 해결할 수도 있었다.
특히 범용성이 있고 장점이 많은 Django프레임워크.
파이썬에서 제공하는 표준 라이브러리를 사용하면 우리가 필요한 웹클라이언트를 직접 개발할 수 있으며, 간단한 테스트용
웹 서버도 즉시 만들 수 있다.
중급자라면 프레임워크들의 장단점을 잘 따져서 자신의 프로젝트에 적합한 프레임워크를 선택해서 사용한다.
Django는 프로그래밍 뼈대를 만들어주고, 데이터베이스 연동, 어드민 관리 기능이 쉽게 처리.
웹프로그램이에 필요한 개념들이 잘 정립되어 있다.
1)웹 프로그래밍에 필요한 파이썬 표준 라이브러리를 활용할 수 있다.
2)웹 서버 뿐 아니라 자신의 목적에 맞는 웹 클라이언트를 개발할 수 있다.
3)파이썬 프레임워크 중 범용성이 가장 높은 장고를 사용해 웹 서버를 개발할 수 있다.
4)Modle, Template, View에 따른 설명과 실습을 통해 Django에서의 애플리케이션 개발 방식과 그 원리를 이해한다.

실습 환경
파이썬은 운영체제가 달라져도 애플리케이션 레벨에서 변경할 것은 없습니다.
커맨드는 운영체제 상관없이 거의 동일하다.
3.x버전에서는 print문법이 함수. 2.x버전에서는 ()를 사용하지 않는다.
models.py에서 __str__()메소드 대신, 2.x에서는 __unicode__()메소드 사용.
장고도 오픈 소스이고, 자료를 찾고 싶으면 공식 홈페이지.

01 웹 프로그래밍의 이해
웹 프로그래밍의 기본 기술에 대해 이해할 수 있어야 한다.
웹 프로그램은 기본적으로 클라이언트-서버로 이루어진다.

1.1 웹 프로그래밍이란?
HTTP(S)프로토콜로 통신하는 클라이언트와 서버를 개발하는 것.
웹 클라이언트와 웹 서버를 같이 개발할 수도 있고, 웹 클라이언트 또는 웹 서버 하나만 개발할 수도 있습니다.
보통은 웹 서버를 개발하는 경우가 많아 웹 프레임워크를 사용해 웹 서버를 개발하는 것.
웹 브라우저를 실행하여 네이버에 접속하는 것도 웹 프로그램이 동작하는 것.
웹 브라우저가 웹 클라이언트고, 네이버 서버는 웹 서버.
웹 클라이언트가 요청하고 웹 서버가 응답하는 클라이언트-서버 프로그램이 동작하는 것.
실제 프로젝트를 진행하다 보면 웹 클라이언트를 개발해야되는 상황도 빈번.
웹 클라이언트<────────────────────────>웹 서버
          요청      HTTP프로토콜     응답
보통은 웹브라우저사용.                주로 웹 프레임워크를 활용하여 웹 서버를 개발함.
개발자가 직접 개발 가능.          

웹 브라우저 외에도 웹 서버에 요청을 보내는 웹 클라이언트는 다양하게 만들 수 있다.
1)웹 브라우저를 사용해 요청
2)리눅스 curl명령어를 사용하여 요청
3)Telnet을 사용하여 요청
4)직접 만든 클라이언트로 요청.

1.2 다양한 웹 클라이언트
네이버와 같은 상용 웹 서버를 사용해도 되지만, www.example.com도메인에 있는 웹 서버를 대상으로 HTTP요청을 보내고 응답확인.

1.2.1 웹 브라우저를 사용하여 요청
웹 브라우저 주소창에 접속하고자 하는 웹 서버의 URL, www.example.com을 입력.
웹 브라우저는 주소창에 입력된 문장을 해석하여 웹 서버에게 HTTP요청을 보내는 웹 클라이언트의 역할을 수행한다.
요청을 받은 www.example.com도메인의 웹 서버는 그 결과를 웹 브라우저로 전송해줍니다.
웹 브라우저는 전송받은 결과를 사용자가 볼 수 있도록 HTML텍스트를 해석하여 화면에 보여줍니다.

1.2.2 리눅스 curl명령어를 사용하여 요청
리눅스 curl명령은 HTTP/HTTPS/FTP 등 여러 가지의 프로토콜을 사용하여 데이터를 송수신할 수 있는 명령입니다.
쉘 프롬프트에서
$ curl http://www.example.com
curl 명령은 인자로 넘어온 URL로 HTTP요청을 보내는 웹 클라이언트의 역할을 수행합니다.
이 요청을 받은 www.example.com도메인의 웹 서버는 그 결과를 응답해줍니다.
<!doctype html>
<html>
<head>
    <title>Example Domain</title>

    <meta charset="utf-8" />
    <meta http-equiv="Content-type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style type="text/css">
    body {
        background-color: #f0f0f2;
        margin: 0;
        padding: 0;
        font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;

    }
    div {
        width: 600px;
        margin: 5em auto;
        padding: 50px;
        background-color: #fff;
        border-radius: 1em;
    }
    a:link, a:visited {
        color: #38488f;
        text-decoration: none;
    }
    @media (max-width: 700px) {
        body {
            background-color: #fff;
        }
        div {
            width: auto;
            margin: 0 auto;
            border-radius: 0;
            padding: 1em;
        }
    }
    </style>
</head>

<body>
<div>
    <h1>Example Domain</h1>
    <p>This domain is established to be used for illustrative examples in documents. You may use this
    domain in examples without prior coordination or asking for permission.</p>
    <p><a href="http://www.iana.org/domains/example">More information...</a></p>
</div>
</body>
</html>
웹 브라우저에서 보았던 문장과 동일하다.
HTML태그들과 <head>부분이 있지만 동일한 응답.
즉, 어떤 방법을 사용하는지와 상관없이 웹 서버는 동일한 요청을 받을 경우 동일한 응답을 주고 있는 것.

1.2.3 Telnet을 사용하여 요청
리눅스 telnet프로그램을 사용해 HTTP요청을 보낼 수도 있습니다.
$ telnet www.example.com 80
telnet명령은 터미널 창에서 입력하는 내용을 그대로 웹 서버에 전송합니다.
여기서는 HTTP프로토콜의 요청 메시지 규격에 정의된 규칙에 따라 HTTP요청을 보낸것으로 
telnet프로그램이 웹 클라이언트 역할을 수행.
요청을 받은 www.example.com도메인의 웹 서버는 그 결과를 응답해줍니다.
Trying 93.184.216.34...
Connected to www.example.com.
Escape character is '^]'.
GET / HTTP/1.1
HOST: www.example.com

HTTP/1.1 200 OK
Accept-Ranges: bytes
Cache-Control: max-age=604800
Content-Type: text/html; charset=UTF-8
Date: Wed, 19 Jun 2019 11:39:53 GMT
Etag: "1541025663+gzip+ident"
Expires: Wed, 26 Jun 2019 11:39:53 GMT
Last-Modified: Fri, 09 Aug 2013 23:54:35 GMT
Server: ECS (sjc/4E67)
Vary: Accept-Encoding
X-Cache: HIT
Content-Length: 1270

<!doctype html>
<html>
<head>
    <title>Example Domain</title>

    <meta charset="utf-8" />
    <meta http-equiv="Content-type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style type="text/css">
    body {
        background-color: #f0f0f2;
        margin: 0;
        padding: 0;
        font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
        
    }
    div {
        width: 600px;
        margin: 5em auto;
        padding: 50px;
        background-color: #fff;
        border-radius: 1em;
    }
    a:link, a:visited {
        color: #38488f;
        text-decoration: none;
    }
    @media (max-width: 700px) {
        body {
            background-color: #fff;
        }
        div {
            width: auto;
            margin: 0 auto;
            border-radius: 0;
            padding: 1em;
        }
    }
    </style>    
</head>

<body>
<div>
    <h1>Example Domain</h1>
    <p>This domain is established to be used for illustrative examples in documents. You may use this
    domain in examples without prior coordination or asking for permission.</p>
    <p><a href="http://www.iana.org/domains/example">More information...</a></p>
</div>
</body>
</html>
응답 메시지를 수신한 후, telnet 프로그램을 종료하기 위해 ctrl+]입력하고 telnet>quit입력한다.
그러면 telnet HTTP응답 메시지의 헤더가 Connection closed를 출력하고 이는 정상적으로 처리된 것이다.

1.2.4 직접 만든 클라이언트로 요청
파이썬 프로그램으로 간단한 웹 클라이언트를 만들어 보자.
example.py
파이썬 프로그램이 웹 클라이언트가 된다.
파이썬 라이브러리를 이용해 두 줄로 웹 서버에 HTTP요청을 보내는 웹 클라이언트를 만들었다.
>python example.py
웹 클라이언트의 형태는 달라도 동일한 요청에 대해서 동일한 응답을 받는다.
또한 반드시 웹 브라우저가 아니더라도 웹 클라이언트의 요청을 보낼 수 있다.
>python -c "import urllib.request;print(urllib.request.urlopen('http://www.example.com').read().decode('utf-8'))"

1.3 HTTP 프로토콜
Hypertext Transfer Protocol는 웹 서버와 웹 클라이언트 사이에서 데이터를 주고받기 위해 사용하는 통신 방법.
TCP/IP프로토콜 위에서 동작한다.
즉, 웹을 이용하려면 웹 서버와 웹 클라이언트는 각각 TCP/IP동작에 필수적인 IP주소를 가져야 한다.
하이퍼텍스트뿐 아니라 이미지 등 컴퓨터에서 다룰 수 있는 모든 데이터를 전송할 수 있다.
예를 들어, 주소창에 네이버를 입력하면 웹 클라이언트와 웹 서버 사이에 HTTP연결이 맺어지고,
웹 클라이언트는 웹 서버에 HTTP요청 메시지를 보내게 됩니다.
웹 서버는 요청에 따른 처리를 진행한 후에 그 결과를 웹 클라이언트에게 HTTP응답 메시지로 보냅니다.
이런 방식으로 요청 메시지와 응답 메시지가 반복적으로 오가면서 웹을 사용하는 것.

1.3.1 HTTP 메시지의 구조
클라이언트에서 서버로 보내는 요청 메시지와 서버에서 클라이언트로 보내는 응답 메시지 2가지가 있다.
Start Line - 요청라인 또는 상태라인
Header     - 헤더는 생략 가능
Blank Line - 헤더의 끝을 빈 줄로 식별
Body       - 바디는 생략 가능
스타트라인은 요청 메시지일 때 요청라인이라 하고, 응답 메시지일 때 상태라인이라고 한다.
헤더는 각 행의 끝에 줄 바꿈 문자인 CRLF(Carriage Return Line Feed)가 있고, 바디와 빈줄로 구분.
헤더와 바디는 생략할 수 있고, 바디는 텍스트뿐만 아니라 바이너리 데이터도 들어갈 수 있다.
예를 들어 바디가 없는 요청 메시지는
GET /book/shakespeare HTTP/1.1
Host: www.example.com:8080
첫 번째 줄은 요청라인으로, 요청방식, 요청 URL, 프로토콜 버전으로 구성됩니다.
두 번째 줄은 헤더로, 이름:값 형식으로 표현하며 여러 줄도 가능.
또한, Host항목은 필수로 표시해야하는데 요청라인의 URL에 Host를 표시하면 Host헤더는 생략할 수 있다.
만약 포트번호를 표시하고 싶다면 Host항목에 같이 표시.
GET http://www.example.com:8080/book/shakespeare HTTP/1.1
응답 메시지는 예를들면
HTTP/1.1 200 OK
Content-Type: application/xhtml+xml; charset=utf-8

<html>
...
</html>
첫 번째 줄의 상태라인은 프로토콜 버전, 상태 코드, 상태 텍스트로 구성됩니다.
서버에서 처리 결과를 상태라인에 표시하는데, 200 OK는 정상적으로 처리되었음.
두 번째 줄부터 헤더입니다.
헤더와 바디는 빈 줄로 구분합니다.
바디에는 보통 HTML텍스트가 표함되어 있습니다.

URI vs URL?
URI는 Uniform Resource Identifier로 URL(Uniform Resource Locator)와 URN(Uniform Resource Name)을
포함하는 더 넓은 의미이다.

1.3.2 HTTP 처리 방식
HTTP메소드를 통해 클라이언트가 원하는 처리 방식을 서버에 알려줍니다.
HTTP메소드는 8가지로 정의되어 있고, 많이 사용되는 것은 GET, POST, PUT, DELETE이고 데이터 조작의 기본이 되는 
CRUD(Create, Read, Update, Delete)와 매핑되는 처리.
GET     - 리소스 취득                     - Read(조회)
POST    - 리소스 생성, 리소스 데이터 추가  - Create(생성)
PUT     - 리소스 변경                     - Update(변경)
DELETE  - 리소스 삭제                     - Delete(삭제)
HEAD    - 리소스의 헤더(메타데이터) 취득
OPTIONS - 리소스가 서포트하는 메소드 취득
TRACE   - 루프백 시험에 사용
CONNECT - 프록시 동작의 터널 접속으로 변경
GET방식은 지정한 URL의 정보를 가져오는 메소드로, 가장 많이 사용.
웹 브라우저를 이용하여 서버로부터 웹 페이지, 이미지 등을 가져오려 할 때 수많은 GET방식의 요청을 사용함.
POST의 대표적인 기능은 리소스를 생성하는 것으로 블로그에 글을 등록하는 경우.
PUT은 리소스를 변경하는 데 사용.
글을 업로드한 작성자를 변경하거나 글의 내용을 업데이트하는 등.
PUT메소드도 리소스를 생성하는 데 사용할 수 있습니다.
새롭게 생성한 리소스에 대한 URL 결정권이 서버 측에 있을 때 POST를 사용하고, 클라이언트에 있을 때 PUT을 사용.
트위터에 글을 포스팅하면 그 글에 대한 URL은 서버에서 결정하므로 POST를 사용하고, 위키처럼 클라이언트가
결정한 타이틀이 그대로 URL이 되는 경우는 PUT을 사용하는 것이 적합.
용도를 구분하는 것보다 리소스의 생성은 POST, 리소스의 변경은 PUT으로 쉽게 이해.
DELETE는 리소스를 삭제하는 메소드.
일반적으로 DELETE 요청에 대한 응답은 바디를 반환하지 않습니다.

1.3.3 GET과 POST 메소드
가장 많이 사용하는 메소드는 GET과 POST이고 HTML의 폼에서 지정할 수 있는 메소드가 GET과 POST밖에 없다.
폼에서 사용자가 입력한 데이터들을 서버로 보낼 때, GET과 POST는 방식에 차이가 있다.
GET은 URL부분의 ?뒤에 이름=값 쌍으로 이어붙여 보냅니다.
GET http://docs.djangoproject.com/search/?q=forms&release=1 HTTP/1.1
POST에서는 GET에서 URL에 포함시켰던 파라미터들을 요청 메시지의 바디에 넣습니다.
POST http://docs.djangoproject.com/search/ HTTP/1.1
Content-Type: application/x-www-form-urlencoded

q=forms&release=1
파라미터를 보내는 방식의 차이로 인해 GET방식을 이용하면 많은 양의 데이터를 보내기 어렵습니다.
URL은 길이 제한이 있기 떄문.
또한 전달되는 사용자의 데이터가 웹 브라우저의 주소창에 노출된다는 단점이 있어 보안 측면에서도 불리합니다.
따라서 폼을 사용하거나 추가적인 파라미터를 서버로 보내는 경우에는 GET보다 POST방식을 많이 이용.
파이썬의 장고 프레임워크에서도 폼의 데이터는 POST방식만을 사용.
이를 제외하고는 GET을 사용해도 무방하다.
예를 들어 네이버 검색창에 단어를 검새갛면 GET방식이 사용되는 것을 확인할 수 있습니다.

1.3.4 상태 코드
서버에서의 처리 결과는 응답 메시지의 상태라인에 있는 상태 코드를 보고 파악할 수 있습니다.
상태 코드는 세 자리 숫자로 되어 있는데, 첫 번째 숫자는 HTTP 응답의 종류를 구분하는데 사용하며, 나머지 두 개의
숫자는 세부적인 응답 내용의 구분을 위한 번호.
메소드명 의미                     CRUD와 매핑되는 역할
1xx     Informational(정보 제공)  임시적인 응답으로, 현재 클라이언트 요청까지 처리되었으니 계속 진행하라는 뜻.
                                  HTTP 1.1 버전부터 추가됨.
2xx     Success                   클라이언트의 요청이 서버에서 성공적으로 처리되었다는 의미.
3xx     Redirection               완전한 처리를 위해 추가적인 동작을 필요로 하는 경우.
                                  주로 서버의 주소 또는 요청한 URI의 웹 문서가 이동되어 다시 시도해보라는 의미.
4xx     Client Error              없는 페이지를 요청하는 것처럼 클라이언트 요청 메시지 내용이 잘못된 경우.
5xx     Server Error              서버 측 사정에 의해 메시지 처리에 문제가 발생한 경우.
                                  서버의 부하, DB처리과정 오류, 서버에서 익셉션 발생하는 경우 등.
상태 코드 상태 텍스트            응답 문구      서버 측면에서의 의미
2xx       Success               성공          클라이언트가 요청한 동작을 수신해 이해했고, 승낙했으며 성공적으로 처리했다.
200       OK                    성공          서버가 요청을 성공적으로 처리했다.
201       Created               생성됨        요청이 처리되어 새로운 리소스가 생성되었다.
                                              응답 헤더 Location에 새로운 리소스의 절대 URI를 기록.
202       Accepted              허용됨        요청은 접수했지만 처리가 완료되지 않았다.
                                              클라이언트는 응답 헤더의 Location, Retry-After를 참고해 다시 요청을 보냄.
3xx       Redirection           리다이렉션     클라이언트는 요청을 마치기 위해 추가적인 동작을 취해야 한다.
301       Moved Permanently     영구 이동      지정한 리소스가 새로운 URI로 이동했다.
                                              이동할 곳의 새로운 URI는 응답 헤더 Location에 기록.
303       See Other             다른 위치 보기 다른 위치로 요청하라.
                                              요청에 대한 처리 결과를 응답 헤더 Location에 표시된 URI에서 GET으로 취득할
                                              수 있습니다. 브라우저의 폼 요청을 POST로 처리하고 그 결과 화면으로 
                                              리다이렉트시킬 때, 자주 사용하는 응답 코드.
307       Temporary Redirect    임시 리다이렉션 임시로 리다이렉션 요청이 필요하다. 
                                               요청한 URI가 없으므로, 클라이언트는 메소드를 그대로 유지한 채 응답 헤더
                                               Location에 표시된 다른 URI로 요청을 재송신할 필요가 있다.
                                               클라이언트는 향후 요청 시 원래 위치를 계속 사용해야 합니다.
                                               302의 의미를 정확하게 재정의해서 HTTP/1.1의 307응답으로 추가되었습니다.
4xx       Client Error          클라이언트 에러 클라이언트의 요청에 오류가 있다.
400       Bad Request           잘못된 요청     요청의 구문이 잘못되었다.
                                               클라이언트가 모르는 4xx계열의 응답 코드가 반환된 경우에도 클라이언트는
                                               400과 동일하게 처리하도록 규정하고 있다.
401       Unauthorized          권한 없음       지정한 리소스에 대한 액세스 권한이 없다.
                                               응답 헤더 WWW-Authenticate에 필요한 인증 방식을 지정합니다.
403       Forbidden             금지됨          지정한 리소스에 대한 액세스가 금지되었다.
                                               401 인증 처리 이외의 사유로 리소스에 대한 액세스가 금지되었음을 의미.
                                               리소스의 존재 자체를 은폐하고 싶은 경우 404응답 코드 사용.
404       Not Found             찾을 수 없음    지정한 리소스를 찾을 수 없다.
5xx       Server Error          서버 에러       클라이언트의 요청은 유효한데, 서버가 처리에 실패했다.
500       Internal Server Error 내부 서버 오류   서버 쪽에서 에러가 발생했다.
                                                클라이언트가 모르는 5xx계열의 응답 코드가 반환된 경우에도 클라이언트는
                                                500과 동일하게 처리하도록 규정하고 있다.
502       Bad Gateway           불량 게이트웨이  게이트웨이나 프록시 역할을 하는 서버가 그 뒷단의 서버로부터 잘못된
                                                응답을 받았다.
503       Service Unavailable   서비스 제공불가  현재 서버에서 서비스를 제공할 수 없다.
                                                보통은 서버의 과부하나 서비스 점검 등 일시적인 상태.

1.4 URL 설계
URL의 설계는 웹 서버 로직 설계의 첫걸음이고, 사용자 또는 웹클라이언트에게 웹 서버가 가지고 있는 기능을 명시해주는
중요한 단계.
전체 프로그램 로직을 생각하면서 차후에 로직이 변경되더라도 URL 변경은 최소화할 수 있도록 유연하게 설계.

URL 구성
http://www.example.com:80/services?category=2&kind=patents#n10
<-->   <-------------><-><-------><----------------------><-->
URL스킴     호스트명    ↑    경로           쿼리스트링        ↑
                    포트번호                              프라그먼트
URL스킴:URL에 사용된 프로토콜을 의미합니다.
호스트명:웹 서버의 호스트명으로, 도메인명 또는 IP주소로 표현됩니다.
포트번호:웹 서버 내의 서비스 포트번호입니다. 생략 시에는 디폴트 포트번호로, http는 80, https는 443을 사용.
경로:파일이나 애플리케이션 경로를 의미.
쿼리스트링:질의 문자열로 앰퍼샌드(&)로 구분된 이름=값 쌍 형식으로 표현합니다.
프라그먼트:문서 내의 앵커 등 조각을 지정합니다.

1.4.1 URL을 바라보는 측면
URL은 웹 클라이언트에서 호출한다는 시점에선 웹 서버에 존재하는 애플리케이션에 대한 API(Application Programming Interface)
웹 프로그래밍 기술의 발전 과정을 살펴보면, API의 명명 규칙을 정하는 방법을 두가지로 분류합니다.
하나는 URL을 RPC(Remote Procedure Call)로 바라보는 방식이고, 다른 하나는 REST(Representational Sure Transfer).
RPC란 클라이언트가 네트워크상에서 원격에 있는 서버가 제공하는 API함수를 호출하는 방식.
URL설계와 API설계를 동일하게 고려하여 URL의 경로를 API함수명으로, 쿼리 파라미터를 함수의 인자로 간주합니다.
그래서 웹 클라이언트에서 URL을 전송하는 것이 웹 서버의 API함수를 호출한다고 인식하는 것.
RPC방식에서는 URL경로의 대부분이 동사가 됩니다.
RPC방식은 웹 개발 초기부터 사용된 방식으로 최근에는 줄어들고 있긴 하다.
http://blog.example.com/search?q=test&debug=true
REST방식이란 웹 서버에 존재하는 요소들을 모두 리소스라고 정의하고, URL을 통해 웹 서버의 특정 리소스를 표현한다는 개념.
리소스는 시간이 지남에 따라 상태가 변할 수 있기 때문에 클라이언트와 서버 간에 데이터의 교환을 리소스 상태의 교환으로 간주.
그리고 중요한 것은 리소스에 대한 조작을 GET, POST, PUT 등의 HTTP 메소드로 구분한다는 것.
그러면 웹 클라이언트에서 URL을 전송하는 것이 웹 서버에 있는 리소스 상태에 대한 데이터를 주고받는 것으로 간주.
http://blog.example.com/search/test - GET메소드 사용

1.4.2 간편 URL
최근에는 REST방식의 URL개념을 기반으로, 간단하면서도 사용자에게 친숙하게 URL을 표현하려는 노력.
그 결과 기존의 길고 복잡한 URL에서 특수 문자 등을 제거하고 간결하게 만드는 방식인 간편 URL이 탄생.
기존 URL방식에서 사용되는 문자(?, =, &, #)들은 웹 프로그래밍 언어 입장에서는 연산자나 특수한 용도의 기호로
사용될 가능성이 높기 때문에 검색 엔진에서 이런 주소를 저장하고 표현하는 데 불편하기도 했었다.
정리하면, 간편 URL은 쿼리스트링 없이 경로만 가진 간단한 구조의 URL을 말한다.
검색 엔진의 처리를 최적화하기 위해 생겨난 간편한 URL은 URL을 입력하거나 기억하기 쉽다는 부수적인 장점도 있어,
검색 엔진 친화적 URL 또는 사용자 친화적 URL이라고 부른다.

1.4.3 파이썬의 우아한 URL
파이썬 프레임워크에서는 처음부터 간편 URL체계를 도입했습니다.
그 외에도 URL을 정의하기 위해 정규표현식을 추가적으로 사용할 수 있습니다.
간편한 URL을 우아한 URL이라고 부르기도 합니다.
장고에서 사용하는 URL의 표현 방식은
urlpatterns = [
    path('articles/2003/', views.special_case_2003),
    path('articles/<int:year>/', views.year_archieve),
    path('articles/<int:year>/<int:month>/', views.month_archieve),
    path('articels/<int:year>/<int:month>/<slug:slug>/', views.article_detail),
]
유사한 의미의 URL을 정규표현식을 사용해 표현할 수도 있습니다.
연도는 정수이기만 하면되지만, 연도는 숫자 4자리만 가능하게 합니다.
정규표현식을 사용하여 URL을 좀 더 구체적으로 표현하는 방식.
urlpatterns = [
    path('articles/2003/', views.special_case_2003),
    re_path(r'^articles/(?P<year>[0-9]{4})/$', views.year_archieve),
    re_path(r'^articles/(?P<year>[0-9]{4})/(?P<month>[0-9]{2})/$', views.month_archieve),
    re_path(r'^articles/(?P<year>[0-9]{4})/(?P<month>[0-9]{2})/(?P<slug>[\w-]+)/$', views.article_detail),
]

1.5 웹 애플리케이션 서버
웹 서버를 세분화하면 웹 서버와 웹 애플리케이션 서버로 분류할 수 있다.
1)웹 서버:웹 클라이언트의 요청을 받아 요청을 처리하고, 그 결과를 웹 클라이언트에게 응답합니다. 주로 정적 페이지인
HTML, 이미지, CSS, 자바스크립트 파일을 웹 클라이언트에 제공할 때 웹 서버를 사용합니다. 만약 동적 페이지 처리가
필요하다면 웹 애플리케이션 서버에 처리를 넘깁니다. (Apache httpd, Nginx, lighttpd, llS 등)
2)웹 애플리케이션 서버:웹 서버로부터 동적 페이지 요청을 받아서 요청을 처리학, 그 결과를 웹 서버로 반환합니다.
주로 동적 페이지 생성을 위한 프로그램 실행과 데이터베이스 연동 기능을 처리합니다. (Apache Tomcat, JBoss,
WebLogic, WebSphere, Jetty, Jeus, mod_wsgi, uWSGI, Gunicorn 등)
웹 서버 및 웹 애플리케이션 서버라는 용어는 SW 측면의 서버 프로그램을 의미한다.

차이점을 할려면 웹 서버 기술의 발전 과정을 알아봐야 한다.
동적 페이지를 생성하는 CGI프로그램.
1)웹 서버 등장
웹 서버
2)CGI 프로그램 등장
웹 서버 <-> CGI 프로그램
3)CGI 대안 기술 2가지
웹 서버 안에 스크립트 엔진 or 웹 서버 <-> 데몬 프로그램
4)웹 애플리케이션 서버 등장
웹 서버 <-> 웹 애플리케이션 서버

1.5.1 정적 페이지 vs 동적 페이지
정적 페이지란 누가, 언제 요구하더라도 항상 같은 내용을 표시하는 웹 페이지를 말합니다.
정적 페이지들은 해당 웹 서비스의 제공자가 사전에 준비하여 서버 측에 배치한 것으로 동일한 리소스의 요청에 대해서는
항상 동일한 내용의 페이지를 반환합니다.
주로 HTML, 자바스크립트, CSS, 이미지만으로 이루어진 페이지.
동적 페이지란 동일한 리소스의 요청이라도 누가, 언제, 어떻게 요구했는지에 따라 각각 다른 내용이 반환되는 페이지.
현재 시각을 보여주는 페이지나 온라인 쇼핑 사이트에서 사용자마다 다른 카트 내용을 보여주는 페이지 등.
정적, 동적이란 용어는 사용자가 페이지를 요청하는 시점에 페이지의 내용이 유지되는가 또는 변경되는가를 구분.
즉, 동적 페이지에는 프로그래밍 코드가 포함되어 있어 페이지 요청 시점에 HTML문장을 만들어내는 것.
초창기 웹에선 논문 열람 사이트 같이 정적인 웹 페이지들을 하이퍼링크로 연결하여 보여주는 것이 목적이었고, 웹 서버도
정적인 페이지를 보여주는 것이 주된 역할.
하지만 점차 동적 페이지에 대한 요구사항이 생기고, 필요한 데이터를 저장하고 꺼내오는 등의 데이터베이스 처리에 대한
요구가 많아짐에 따라 웹 서버와는 다른 별도의 프로그램이 필요하게 됨.
이러한 별도의 프로그램과 웹 서버 사이에 정보를 주고받는 규칙을 정의한 것이 CGI(Common Gateway Interface).

1.5.2 CGI 방식의 단점
CGI자체는 웹 서버와 독립적인 프로그램(프로세스)사이에 정보를 주고받는 규격을 의미하며, 언어와는 무관.
전통적인 CGI방식은 웹 서버가 C,C++,Perl,PHP,Python 등으로 만들어진 CGI프로그램을 직접 호출하여 개별 프로세스를
생성하는 방식.
웹 클라이언트 <─────────> 웹 서버 ───> C
           응답       요청       ───> Perl
                                ───> PHP 
                            독립적인 프로세스로 실행
CGI 방식의 근본적인 문제점은 각각의 클라이언트 요청에 대해 독립적인 별도의 프로세스가 생성된다는 것.
요청이 많아지면 프로세스가 많아지고, 비례적으로 점유하는 메모리 요구량도 커져 시스템에 많은 부하.
그래서 현재는 CGI방식을 거의 사용하지 않으며, 대안책으로 여러 가지 기술이 등장.

1.5.3 CGI 방식의 대안 기술
대안 기술 중 하나는 별도의 애플리케이션(CGI프로그램과 같은 역할을 하는 프로그램)을 Perl, PHP 등의 스크립트 언어로
작성하고, 스크립트를 처리하는 스크립트 엔진(인터프리터)을 웹 서버에 내장시켜 CGI방식의 단점인 오버헤드를 줄이는 방식.
아파치 웹 서벗에서 사용하는 mod_perl이나 mod_php 모듈이 Perl이나 PHP스크립트 엔진을 웹 서버에 내장시켜 
애플리케이션의 처리를 고속화하기 위해 개발된 기술들.
파이썬의 경우에는 예전의 mod_python 모듈은 더 이상 사용하지 않으며, mod_wsgi 모듈을 사용한다.
또 다른 방식은 애플리케이션을 처리하는 프로세스를 미리 데몬으로 기동시켜 놓은 후, 웹 서버의 요청을 데몬에서 처리하는 것.
이 방식도 프로세스 생성 부하를 줄일 수 있는 방법.
파이썬의 경우에는 데몬 방식에도 mod_wsgi 모듈을 사용한다.
mod_wsgi 모듈은 웹 서버 내장 방식으로도 실행이 가능하고, 별도의 데몬 방식으로도 실행이 가능.
CGI 애플리케이션을 별도의 데몬으로 처리하는 방식은 기술이 발전함에 따라, 쓰레드 처리가 보강되고 객체 지향 기술이 
반영되면서 애플리케이션 전용 데몬인 애플리케이션 서버 방식으로 발전하였다.
현재 가장 많이 사용하고 있는 JSP(Jave Server Page), ASP(Active Server Page)에서 애플리케이션 서버 방식을 사용.
파이썬에서 웹 서버와 연동용으로 사용하는 mod_wsgi, uwsgi, gunicorn프로그램들이 웹 서버 프로그램인 httpd, nginx와는
별개의 애플리케이션 전용 데몬으로 동작한다는 점에서 웹 애플리케이션 서버라고 할 수 있다.
데몬은 주기적인 서비스 요청을 처리하기 위해 계속 실행되는 프로그램을 말한다.

1.5.4 애플리케이션 서버 방식
애플리케이션 서버 방식은 웹 서버가 웹 애플리케이션 서버를 통해 간접적으로 앱 애플리케이션 프로그램을 실행한다.
웹 애플리케이션 서버는 애플리케이션 프로그램의 실행 결과를 웹 서버에 전달해주며, 웹 서버는 웹 애플리케이션 서버로부터
전달받은 응답 결과를 웹 클라이언트에 전송합니다.
             요청      처리 위임
웹 클라이언트 ───> 웹 서버 ───> 웹 애플리케이션 서버 ───> 애플리케이션 
             <───        <───                     ───> 애플리케이션
             응답      결과 반환                        ...
                                        웹 애플리케이션 서버에서 실행
             요청      처리 위임
웹 클라이언트 ───> 웹 서버 ───> 웹 애플리케이션 서버 <───> 데이터베이스 서버 
             <───        <───                    DB 연동
             응답      결과 반환                      
웹 서버와 웹 애플리케이션 서버가 분리됨에 따라, 서로의 역할도 구분하여 사용하는 것이 좋다.
왜냐하면 정적 페이지를 처리하는 경우에 비해 동적 페이지를 처리하는 경우가 훨씬 많이 메모리를 소비하기 때문.
즉, 정적 페이지 처리에 특화된 웹 서버는 정적 페이지만 처리하고, 웹 애플리케이션 서버는 동적 페이지만 처리하도록.
웹 서버는 정적 페이지를 웹 클라이언트에게 제공하는 것이 주 역할이지만, 그 외에도 캐시 기능, 프록시 기능 등 추가적인 기능.
또한 다수의 클라이언트로부터 동시에 요청을 받아 처리해야 하기 때문에 동시에 접속을 허가하는 클라이언트 수의 제한 및
처리 프로세스의 관리, 요청 및 응답에 대한 로그의 기록, 안정성 확보를 위한 인증 제어 및 암호화 처리 등 HTTP/HTTPS의
제어에 필요한 여러 가지 기능을 제공합니다.
웹 애플리케이션 서버는 웹 서버보다 기능이 더 추가되고, 종류도 다양해지고 있다.
웹 애플리케이션 서버는 웹 서버와 연동 규격만 잘 따르면 임의의 언어 플랫폼을 사용해 애플리케이션 프로그램을 작성하고
실행시킬 수 있기 때문.
자바 계열은 Tomcat, 루비 계열의 Unicorn, 파이썬 계열의 uWSGI 애플리케이션 서버 등이 대표적.
대다수의 웹 애플리케이션 서버는 웹 클라이언트로부터 직접 요청을 받아 처리하는 웹 서버의 기능을 제공합니다.
그러나 웹 애플리케이션 서버 내의 웹 서버 기능들이 성능과 안정성 측면에서는 적합하지 않아 개발용으로만 제한적으로
사용되고, 운용 환경이나 대규모의 사이트에서는 사용되지 않는다.

1.5.5 웹 서버와의 역할 구분
웹 서버 및 웹 애플리케이션 서버는 SW측면의 서버 프로그램을 의미했습니다.
HW측면의 용어를 의미할 때도 있는데, 웹 서버 박스와 웹 애플리케이션 서버 박스라는 용어를 사용한다.
             요청      처리 위임
웹 클라이언트 ───> 웹 서버 ───> 웹 애플리케이션 서버 <───> 데이터베이스 서버 
             <───        <───                    DB 연동
             응답      결과 반환
                 └──────────────────────────────┘
        동일한 HW박스에 배치할 수도 있고, 다른 HW박스에 배치할 수도 있다.        
정적 페이지를 처리할 때와 동적 페이지를 처리할 때의 서버 자원 소모량이 달라 한 가지 서버로 서비스하는 것은 비효율적.
따라서 웹 서버와 웹 애플리케이션 서버 프로그램이 함께 필요하며, 두 개의 서버를 동일한 HW박스에서 기동시키는 것도 가능.
서비스 운용 관리 측면에서 하나의 HW박스에 구성하는 것이 좀 더 간편한 방식이기 때문.
HW박스를 분리하여 구성하면 메모리 효율을 더욱 더 높일 수 있습니다.
정적 페이지를 처리하는 웹 서버 박스와 동적 페이지를 처리하는 웹 애플리케이션 서버 박스 간의 메모리 사이즈 비율을 
조절할 수 있기 때문이다.
그러려면 해당 웹 사이트의 트래픽 중 정적 페이지와 동적 페이지 요청 건수 비율을 분석해야 합니다.
그래서 대형 웹 사이트에서는 HW증설에 의해 웹 처리 용량을 높이는 작업이 용이하도록, 웹 서버를 탑재하는 HW박스와
웹 애플리케이션 서버를 탑재하는 HW박스를 분리하여 구성하는 것이 보통입니다.
이런 경우 HW측면에서 L4 또는 L7 스위치 및 리버스 프록시 HW 박스 등의 도입을 고려하여 구성하게 된다.
