4.1 Admin 사이트 꾸미기
장고의 Admin사이트는 데이터베이스에 들어있는 데이터를 쉽게 관리할 수 있도록 데이터의 생성, 조회, 변경, 삭제 등의 기능을 제공.
프로세스의 상태 조회, 기동 및 정지 등의 프로세스 관리 기능은 제공하지 않습니다.
장고의 Admin 기능은 데이터 관리를 쉽게 해주고, UI도 깔끔하게 정돈된 모습의 Look and Feel을 제공해주고, 자신의 취향에 맞게 
꾸미는 것도 가능하다.
Admin 사이트에 접속하기 위해서 runserver를 기동하고, 주소창에 http://127.0.0.1:8000/admin/

4.1.1 데이터 입력 및 수정
정상적으로 로그인이 되면 화면이 나타나고 테이블에 데이터를 입력하거나 수정할 수 있습니다.
원하는 질문을 클릭하면 선택한 레코드의 상세 페이지가 나타납니다.
이 화면은 models.py에 정의한 테이블 모델을 기초로 장고가 자동으로 생성해주는 것.
장고는 models.py 파일에 정의한 필드 타입에 따라, CharField, DateTimeField 필드 타입에, 적합한 UI위젯을 보여줍니다.
모델 클래스와 Admin UI 간 위젯 매핑
#위의 내용 동일
class Question(models.Model):
    question_text = models.CharField(max_length=200)
    pub_date = models.DateRTimeField('date published')
#아래 내용 동일
필드나 Date, Time 필드 값을 임의로 수정할 수 있다.
Save:변경사항을 저장하고 현 객체의 리스트를 보여주는 페이지로 돌아갑니다.
Save and continue editing:변경사항을 저장하고 현재의 페이지를 다시 보여줍니다.
Save and add another:변경사항을 저장하고 새로운 레코드를 추가할 수 있는 폼 페이지를 보여줍니다.
Delete:삭제 확인 페이지를 보여줍니다.
만약 Time의 [Now]버튼을 눌러도 현재 시간과 동일하지 않다면, settings.py모듈의 TIME_ZONE 세팅.
TIME_ZONE = 'Asia/Seoul'
[History]로 객체의 변경사항, 변경시간, 작업한 유저 등에 대한 변경 이력을 볼 수 있다.

4.1.2 필드 순서 변경하기
테이블을 보여주는 UI양식을 변경하려면 polls/admin.py 파일을 변경하면 됩니다.
#위의 내용 동일
class QuestionAdmin(admin.ModelAdmin):
    fields = ['pub_date', 'question_text'] #필드 순서 변경
admin.site.register(Question, QuestionAdmin)
admin.site.register(Choice)
즉, ModelAdmin클래스를 상속받아 QuestionAdmin클래스를 정의하고, 그 클래스를 admin.site.register()의 두 번째 인자로 등록.

4.1.3 각 필드를 분리해서 보여주기
polls/admin.py 파일을 수정하면 각 필드를 분리해서 보여줄 수 있습니다.
#위의 내용 동일
class QuestionAdmin(admin.ModelAdmin):
    fieldsets = [
        ('Question Statement', {'fields':['question_text']}),
        ('Date Information', {'fields':['pub_date']}),
    ]
#아래 내용 동일
fieldsets에 있는 각 튜플의 첫 번째 인자가 해당 필드의 제목이 됩니다.
각 필드가 분리되고 새로 정의한 제목도 보입니다.

4.1.4 필드 접기
필드 항목을 접을 수도 있습니다.
필드 순서 변경, 필드 분리, 필드 접기는 필드 개수가 많아 폼이 길어진 경우에 유용하게 사용.
polls/admin.py
#위의 내용 동일
    ('Date Information', {'fields':['pub_date'], 'classes':['collapse']}),
#아래 내용 동일

4.1.5 외래키 관계 화면
이번 절에서는 Choice 모델 클래스에 대해 추가, 변경 작업.
Question과 Choice 모델 클래스는 1:N관계로 이루어져 있고, 서로 외래키로 연결되어 있다.
Choice를 추가하려하면 Question 테이블의 질문을 선택하는 항목도 생긴다.
즉, 테이블의 외래키 정의가 Admin UI에서 선택 박스 위젯으로 보여주는 것.
Choice 테이블의 각 레코드는 독립적으로 생성될 수 없고, Question 테이블의 특정 레코드에 외래키로 연결되어야 하기 때문.
하지만, 답변 항목이 많아지면 번거로운 작업이 되어 한 화면에서 한 번에 처리할 수 있도록 UI를 변경할 수 있습니다.

4.1.6 Question 및 Choice를 한 화면에서 변경하기
polls/admin.py을 수정하면 Question과 Choice text를 같이 보면서 수정이나 추가할 수 있습니다.
Question 레코드를 기준으로 여러 개의 Choice레코드가 연결되므로, ChoiceAdmin이 아니라 QuestionAdmin클래스를 수정.
#위의 내용 동일
class ChoiceInline(admin.StackedInline):
    model = Choice
    extra = 2
class QuestionAdmin(admin.ModelAdmin):
    fieldsets = [
        (None, {'fields':['question_text']}),
        ('Date information', {'fields':['pub_date'], 'classes':['collapse']}),
    ]
    inlines = [ChoiceInline] #Choice 모델 클래스 같이 보기
admin.site.register(Question, QuestionAdmin)
admin.site.register(Choice)
extra변수로 지정한 값에 따라, 한 번에 보여주는 Choice text의 숫자가 결정됩니다.

4.1.7 테이블 형식으로 보여주기
항목이 많아지면 더 보기 편리하도록 테이블 형식으로.
polls/admin.py
#위의 내용 동일
class ChoiceInline(admin.TabularInline):
#아래 내용 동일
[Delete] 칼럼에 체크 표시를 하고 [SAVE]버튼을 클릭하면, 해당 답변 항목을 삭제할 수 있다.

4.1.8 레코드 리스트 칼럼 지정하기
각 레코드의 제목은 장고가 디폴트로 models.py에서 정의한 __str__() 메소드의 리턴값을 레코드의 제목으로 사용합니다.
디폴트 형식을 바꾸려면 polls/admin.py 에 list_display 속성을 한 줄 추가하면 컬럼 항목을 지정할 수 있다.
#위의 내용 동일
inlines = [ChoiceInline] #Choice 모델 클래스 같이 보여주기
list_display = ('question_text', 'pub_date') #레코드 리스트 칼럼 지정
#아래 내용 동일
제목이 변경되고, DATE PUBLISHED 컬럼이 추가됩니다.
각 컬럼의 해더를 클릭하면 해당 컬럼을 기준으로 정렬하여 보여줍니다.

4.1.9 list_filter 필터
polls/admin.py에 list_filter 속성을 한 줄 추가하면, UI 화면 우측에 필터 사이드 바를 붙일 수도 있습니다.
#위의 내용 동일
inlines = [ChoiceInline] #Choice 모델 클래스 같이 보여주기
list_display = ('question_text', 'pub_date') #레코드 리스트 칼럼 지정
list_filter = ['pub_date'] #필터 사이드 바 추가
#아래 내용 동일
[FILTER]에는 필터에 사용된 기준 필드 타입에 따라, 장고가 자동으로 적절한 항목들을 보여줍니다.
pub_date필드의 타입이 DateTimeField 타입이므로, 장고가 이에 따라 Any date, Today 등의 옵션 항목을 제공해주고 있다.

4.1.10 search_fields
polls/admin.py에 search_fields 속성을 추가하면 UI화면에 검색 박스를 표시할 수 있다.
#위의 내용 동일
inlines = [ChoiceInline] #Choice 모델 클래스 같이 보여주기
list_display = ('question_text', 'pub_date') #레코드 리스트 칼럼 지정
list_filter = ['pub_date'] #필터 사이드 바 추가
search_fields = ['question_text'] #검색 박스 추가
#아래 내용 동일
검색 박스에 단어를 입력하면 장고는 LIKE 쿼리로 question_text 필드를 검색합니다.
search_fields 속성에 여러 개의 필드를 지정하면 지정한 모든 필드에서 입력된 단어를 검색합니다.

4.1.11 polls/admin.py 변경 내역 정리

4.1.12 Admin 사이트 템플릿 수정
Admin 사이트의 템플릿도 장고의 템플릿 시스템을 사용하고 있습니다.
Admin 사이트의 템플릿 파일을 변경하면 Admin 사이트의 모양을 개발자 취향에 맞게 수정할 수 있다.
그러려면 장고의 기본 Admin 템플릿 파일을 프로젝트로 복사해온 다음, 이를 변경해야 합니다.
프로젝트 내에 템플릿 디렉토리를 새로 만들고 이 디렉토리에 Admin 템플릿 파일을 복사해옵니다.
이 디렉토리는 프로젝트 전체의 룩앤필에 영향을 주거나 공통적으로 사용되는 템플릿을 담는 프로젝트 템플릿 디렉토리.
또한, 새로 만든 프로젝트 템플릿 디렉토리를 settings.py 파일에 등록해 장고가 찾을 수 있도록 합니다.
ch4>mkdir templates
ch4>mkdir templates\admin
ch4>copy (path)\site-packages\django\contrib\admin\templates\admin\base_site.html templates\admin\
mysite/settings.py
#위의 내용 동일
TEMPLATES = [
    {
        ...
        'DIRS':[os.path.join(BASE_DIR, 'templates')],
        ...
    }
]

장고의 설치 디렉토리
>python -c "import django;print(django.__path__)"

base_site.html파일을 복사해왔으니, 원하는 내용으로 수정하면 됩니다.
Admin 사이트의 Django administration이라는 제목을 SHK Polls Administration으로 수정.
base_site.html
#아래 1줄 수정
<h1 id="site-name"><a href="{% url 'admin:index' %}">SHK Polls Administration</a></h1>
다시 Admin 사이트에 접속하면 제목이 변경되어 있다.
이렇게 수정하면 취향에 맞게 룩앤필을 변경할 수 있다.
유의사항은 템플릿 파일을 복사해올 때 타깃 디렉토리를 templates가 아니라 templates/admin 디렉토리로 해야 장고가 템플릿 파일을
찾을 수 있습니다.

리눅스와 윈도우 OS 간 줄바꿈 문자 변환하기
줄바꿈 문자는 리눅스에서 "\n"이고 윈도우에서 "\r\n"이므로 변환이 필요합니다. 자동으로 변환해주는 에디터도 많지만 수동.
base_site.html 파일도 리눅스 파일이므로 notepad로 줄바꿈 문자가 깨진다면 
>type base_site.html | more /P > imsi.html
>move imsi.html base_site.html

4.2 장고 파이썬 쉘로 데이터 조작하기
Admin 사이트는 장고의 장점 중 하나로 관리자가 UI 화면에서 데이터를 조회, 입력, 수정, 삭제할 수 있는 아주 편리한 기능.
장고는 추가로 파이썬 쉘을 이용하여 데이터를 관리할 수 있는 API도 제공하고 있습니다.
쉘 데이터 처리는 복잡하지만 더 다양한 데이터 관리 명령이 가능합니다.
그래서 간단하거나 일반적인 데이터 관리나 UI에서 데이터 모습을 확인하려면 Admin사이트를 이용하고,
복잡한 데이터 처리나 별도로 웹 브라우저로 접속할 필요가 없는 경우는 쉘로 데이터를 처리하는 것이 보통.
장고 파이썬 쉘에서는 ORM을 포함한 일반 파이썬 문법도 실습할 수 있다.
>python manage.py shell
장고 파이썬 쉘 명령도 파이썬 쉘을 기동하는 것.
다른점은 manage.py 모듈에서 정의한 DJANGO_SETTINGS_MODULE 속성을 이용해 미리 mysite/settings.py 모듈을 임포트한다.
테이블은 레코드의 모음이고 장고의 ORM은 테이블의 구조를 클래스로 표현합니다.
클래스의 객체를 생성하는 것은 테이블의 레코드를 생성하는 것.

4.2.1 Create - 데이터 생성/입력
테이블에 레코드를 생성하기 위해서는 필드값을 지정하여 객체를 생성한 후에 save() 메소드를 호출하면 됩니다.
save() 명령이 실행되기 전에는 메모리에서만 변경된 것이므로, 데이터베이스에 반영하기 위해서는 save() 명령을 실행해야 한다.
이 명령은 내부적으로 SQL 용어의 INSERT 문장을 실행.
>>> from polls.models import Question, Choice
>>> from django.utils import timezone
>>> q = Question(question_text="What's new?", pub_date=timezone.now())
>>> q.save()

4.2.2 Read - 데이터 조회
데이터베이스로부터 데이터를 조회하기 위해서는 QuerySet 객체를 사용합니다.
QuerySet은 데이터베이스 테이블로부터 꺼내 온 객체들의 콜렉션입니다.
QuerySet은 필터를 가질 수 있으며, 필터를 사용해 QuerySet 내의 항목 중에서 조건에 맞는 레코드만 다시 추출.
QuerySet은 SELECT 문장에 해당하며, 필터는 WHERE 절에 해당.
조회 결과를 담는 QuerySet을 얻으려면 objects 객체를 사용합니다.
objects 객체는 테이블 정보를 담고 있는 객체입니다.
>>> Question.objects.all() #'Question테이블.레코드들.모두'라고 해석하면 된다.
실행하면 테이블에서 모든 Question 객체를 담고 있는 QuerySet 콜렉션을 반환합니다.
Question클래스는 테이블에 해당하고, Question 객체는 특정 레코드 하나에 해당하며, objects.all()은 레코드들 모두를 의미.
조건에 맞는 일부 레코드만 검색할 때는 filter()와 exclude() 메소드를 사용.
filter():주어진 조건에 맞는 객체들을 담고 있는 QuerySet 콜렉션을 반환함.
exclude():주어진 조건에 맞는 객체들을 제외한 QuerySet 콜렉션을 반환함.
QuerySet 메소드들은 실행 결과 또한 QuerySet 콜렉션을 반환하므로 체인식 호출이 가능.
>>> Question.objects.filter(question_text__startswith='What').exclude(pub_date__gte=datetime.date.today()).filter(
    pub_date__gte=datetime(2005,1,30)
)
한 개의 요소만 있는 것이 확실한 경우에는 get() 메소드를 호출하면 됩니다.
호출 결과는 QuerySet이 아닌 한 개의 객체.
>>> one_entry = Question.objects.get(pk=1)
또한, QuerySet 요소의 개수를 제한하기 위해 슬라이싱 문법을 사용할 수도 있다.
OFFSET, LIMIT절에 해당.
실행 결과는 QuerySet이 아닌 리스트를 반환.
>>> Question.objects.all()[:5]
>>> Question.objects.all()[5:10]
>>> Question.objects.all()[:10:2]

콜렉션이란?
다수의 객체를 한 곳에 모아서 각 객체들을 동일한 방식으로 다룰 수 있도록 해주는 데이터 구조.

4.2.3 Update - 데이터 수정
이미 존재하는 객체에 대한 필드값을 수정하는 경우에도 필드 속성값을 수정한 후 save() 메소드를 호출하면 된다.
UPDATE 절에 해당.
>>> q.question_text = 'What is your favorite hobby ?'
>>> q.save()
여러 개의 객체를 한꺼번에 수정하려면 update() 메소드를 사용.
>>> Question.objects.filter(pub_date__year=2007).update(question_text='Everything is the same')

4.2.4 Delete - 데이터 삭제
객체를 삭제하려면 delete() 메소드를 사용.
delete()는 DELETE 절에 해당.
>>> Question.objects.filter(pub_date__year=2005).delete()
pub_date필드의 연도가 2005년인 모든 객체를 삭제하는 명령.
>>> Question.objects.all().delete()
Question 테이블의 모든 레코드를 삭제하는 명령.
>>> Question.objects.delete()는 장고에서 허용하지 않는 문장.
허용하지 않는 이유는 all()이란 문구를 사용하게 함으로써 의도치 않게 모든 레코드를 삭제하는 실수를 줄이기 위함.

4.2.5 polls 애플리케이션의 데이터 실습
>python manage.py shell
# 정의한 모델을 사용하기 위해 임포트
>>> from polls.models import Question, Choice
# 현재 각 테이블에 들어있는 레코드를 확인합니다.
# Question 레코드 3개
>>> Question.objects.all()
[<QuerySet [<Question: What is your hobby?>, <Question: What do you like best?>, <Question: Where do you live?>]>]
# Choice 레코드 6개
>>> Choice.objects.all()
[<QuerySet [<Choice: Reading>, <Choice: Soccer>, <Choice: Climbing>, <Choice: Seoul>, <Choice: Daejeon>, <Choice: Jeju>]>]
# 추가로 레코드 하나를 생성.
# 날짜를 입력하기 위해 timezone 모듈을 임포트
# settings.py 모듈에 TZ 세팅이 제대로 되어 있어야 한다.
# datetime.datetime.now() 보다는 timezone.now() 사용을 추천
>>> from django.utils import timezone
>>> q = Question(question_text="What's up?", pub_date=timezone.now())
# 데이터베이스에 저장을 위해 save() 함수를 호출.
>>> q.save()
# id 속성이 자동으로 생성된 것을 확인.
>>> q.id
4
# 속성에 접근할 때는 파이썬 문법 그대로 '.'을 사용
>>> q.question_text
"What's up?"
>>> q.pub_date
datetime.datetime(2019, 7, 3, 15, 20, 46, 679097, tzinfo=<UTC>)
# 기존의 속성값을 변경하고 데이터베이스에 저장합니다.
>>> q.question_text = "What's new?"
>>> q.save()
# 테이블의 모든 레코드를 조회.
>>> Question.objects.all()
[<QuerySet [<Question: What is your hobby?>, <Question: What do you like best?>, <Question: Where do you live?>, 
<Question: What's new?>]>]
# 레코드 제목이 [<Question:Question object>]로 나오면, models.py에 __str__() 메소드를 확인.
# 파이썬 쉘을 빠져 나오려면, exit()나 Ctrl-Z(리눅스는 Ctrl-D)를 입력.
>>> exit()

__str__()메소드
객체를 스트링으로 표현해주는 메소드로 파이썬의 모든 클래스에 정의가 가능.
Question 객체를 알아보기 쉬운 스트링으로 표현하기 위해 self.question_text를 사용.

>>> from polls.models import Question, Choice
# 조건에 맞는 레코드를 조회하는 기능.
# 조건 표현에는 filter() 함수 및 키워드 인자를 사용.
# startswith와 같은 연산자를 붙일 때는 __(밑줄 2개)를 사용.
>>> Question.objects.filter(id=1)
[<QuerySet [<Question: What is your hobby?>]>]
>>> Question.objects.filter(question_text__startswith='What')
[<QuerySet [<Question: What is your hobby?>, <Question: What's new?>]>]
# 올해 생성된 질문을 조회.
>>> from django.utils import timezone
>>> current_year = timezone.now().year
>>> Question.objects.filter(pub_date__year=current_year)
[<QuerySet [<Question: What is your hobby?>, <Question: What's new?>]>]
# id 값을 잘못 지정하면 익셉션이 발생합니다.
DoesNotExist: Question matching query does not exist.
# Primary Key로 조회하는 것은 흔히 사용하는 조회 명령입니다.
# Question.objects.get(id=1) 과 동일
>>> Question.objects.get(pk=1)
<Question: What is your hobby?>
# Choice 모델에 관련된 명령들.
# Question과 Choice 테이블의 관계는 1:N의 관계로 Foreign Key로 정의되어 있다.
# 이런 경우 장고는 choice_set API를 제공.
# choice -> Question 방향에는 question 속성을, Question -> Choice 방향으로는 choice_set 속성을 사용.
# 우선, Question 테이블의 레코드 하나를 지정.
>>> q = Question.objects.get(pk=2)
# 질문 레코드에 연결된 답변 항목을 모두 조회합니다.
>>> q.choice_set.all()
<QuerySet []>
# 질문의 답변 항목 3개를 생성.
# create() 함수를 호출하면 Choice 객체를 생성해 데이터베이스에 저장하고,
# choice_set 리스트에 추가한 다음 생성된 객체를 반환합니다.
>>> q.choice_set.create(choice_text='Sleeping', votes=0)
<Choice: Sleeping>
>>> q.choice_set.create(choice_text='Eating', votes=0)
<Choice: Eating>
>>> c = q.choice_set.create(choice_text='Playing', votes=0)
# Choice 객체에서 자신과 연결된 Question 객체를 조회할 수 있습니다.
>>> c.question
<Question: What do you like best?>
# 반대로, Question 객체 역시 자신과 연결된 Choice 객체를 조회할 수 있다.
>>> q.choice_set.all()
[<QuerySet [<Choice: Sleeping>, <Choice: Eating>, <Choice: Playing>]>]
>>> q.choice_set.count()
3
# 밑줄 2개(__)를 사용해 객체 간의 관계를 표현할 수 있다.
# pub_date 속성이 올해인 Question 객체에 연결된 Choice 객체를 모두 조회하는 명령.
# 'current_year' 변수는 앞에서 정의했다.
>>> Choice.objects.filter(question__pub_date__year=current_year)
[<QuerySet [<Choice: Reading>, <Choice: Soccer>, <Choice: Climbing>]>]
# choice_set 중에서 한 개의 답 변 항목을 삭제할 수 있습니다.
>>> c = q.choice_set.filter(choice_text__startswith='Sleeping')
>>> c.delete()
장고 파이썬 쉘에서 중요한 점은 SQL 쿼리 문장을 사용하지 않고도 데이터베이스에 대한 처리를 할 수 있다는 점.

4.3 템플릿 시스템
UI를 담당하고 있는 기능이 템플릿 시스템.
템플릿 코드를 작성 시에 HTML 코드와 장고의 템플릿 코드가 섞이지만, 중요한 점은 템플릿에서는 로직을 표현하는 것이 아닌
사용자에게 어떻게 보여줄지에 대한 룩앤필을 표현.
템플릿 코드에 if태그, for태그 등이 있지만, 파이썬 프로그래밍 언어의 문법과 다르고 템플릿 시스템 고유의 문법.
장고의 템플릿 시스템은 템플릿 문법으로 작성된 템플릿 코드를 해석하여 템플릿 파일로 결과물을 만들어줌.
템플릿 코드를 템플릿 파일로 해석하는 과정을 랜더링이라고 합니다.
결과물인 템플릿 파일은 HTML, XML, JSON 등 단순한 텍스트 파일.
문법이 적용된 화면이 결국은 화면 디자인 측면에서 어떤 효과를 주는지 예측하면서 이해하는 것이 중요.

템플릿 코드 vs 템플릿 파일
렌더링 전의 템플릿 문법에 따라 작성된 파일은 템플릿 코드, 후의 결과물인 HTML과 같은 텍스트 파일은 템플릿 파일.

4.3.1 템플릿 변수
템플릿 코드에서는 변수를 사용할 수 있다.
{{ variable }}
템플릿 시스템은 변수를 평가해서 변수값을 출력해줍니다.
변수명은 일반 프로그래밍의 변수명처럼 문자, 숫자, 밑줄(_)을 사용해 이름을 정의.
또한 변수의 속성에 접근할 수 있는 도트(.) 표현식도 가능.
템플릿 문법에서 도트(.)를 만나면 장고는 다음 순서로 찾기(lookup)를 시도합니다.
예를 들어, foo.bar라는 템플릿 변수가 있다면
1)foo가 사전 타입인지를 확인하고 맞으면 foo['bar']로 해석.
2)그 다음은 foo의 속성을 찾습니다. bar라는 속성이 있으면 foo.bar로 해석.
3)그것도 아니면 foo가 리스트인지를 확인해서 리스트이면 foo[bar]로 해석.
템플릿 시스템은 정의가 되어 있지 않은 변수를 사용하면 빈 문자열('')로 채워주며, 이 값을 변경하려면 settings.py 파일에
속성을 지정해주면 됩니다.
TEMPLATE_STRING_IF_INVALID
디폴트는 빈 문자열입니다.

4.3.2 템플릿 필터
필터란 어떤 객체나 처리 결과에 추가적으로 명령을 적용하여 해당 명령에 맞게 최종 결과를 변경하는 것.
장고의 템플릿 문법에서도 템플릿 변수에 필터를 적용해 변수의 출력 결과를 변경할 수 있다.
필터는 파이프(|) 문자를 사용.
name 변수 값의 모든 문자를 소문자로 바꿔주는 필터는
{{ name|lower }}
필터를 체인으로 연결할 수도 있다.
text 변수값 중 특수 문자를 이스케이프해주고, 그 결과 스트링에 HTML <p> 태그를 붙여주는 것은
{{ text|escape|linebreaks }}
몇 필터는 인자를 가질 수 있습니다.
bio 변수값 중에서 앞에 30개의 단어만 보여주고, 줄 바꿈 문자는 모두 없애주는 것은
{{ bio|truncatewords:30 }}
필터의 인자에 빈칸이 있는 경우는 따옴표로 묶어줍니다.
만일 list가 ['a','b','c']라면 결과는 "a // b // c"가 됩니다.
{{ list|join:" // " }}
value 변수값이 False이거나 없는 경우, "nothing"으로 보여줍니다.
{{ value|default:"nothing" }}
value 변수값의 길이를 반환합니다.
value가 스트링이나 리스트도 가능합니다.
value가 ['a','b','c']면 결과는 3.
{{ value|length }}
value 변수값에서 HTML 태그를 모두 없애줍니다. 그러나 100% 보장하는 것은 아니다.
{{ value|striptags }}
복수 접미사 필터.
{{ value|pluralize }}
value 변수값이 1이 아니면 복수 접미사s를 붙여줍니다. 다른 복수 접미사 es또는 ies를 붙일 때는 필터에 인자를 사용.
{{ value|pluralize:"es" }} 나 {{ value|pluralize:"ies" }}
더하기 필터는 value변수값이 4라면, 최종 결과는 6이 될 것입니다.
이 필터는 데이터 타입에 따라 결과가 달라지므로 주의.
{{ value|add:"2" }}
처음에는 value와 add인자가 모두 integer 타입이라고 간주하고 덧셈을 시도합니다.
실패하면 타입이 허용하는 문법에 따라 더하기를 시도.
그래도 실패하면 빈 문자열을 반환.
예를 들어 {{ first|add:second }}에서
first="python", second="django"라면 결과는 "pythondjango"가 됩니다.
first=[1,2,3], second=[4,5,6]라면 결과는 [1,2,3,4,5,6]이 됩니다.
first="5", second="10"이라면 결과는 15가 됩니다.

장고는 약 60여개의 필터를 제공하고 있고 사용자 정의필터를 만들 수도 있다.

4.3.3 템플릿 태그
탬플릿 태그는 {% tag %} 형식을 가지며, 템플릿 변수나 필터에 비해 복잡한 편.
어떤 태그는 시작 태그와 끝 태그 둘 다 있어야 합니다.
텍스트 결과물을 만들기도 하고, 템플릿 로직을 제어하기도 하며, 외부 파일을 템플릿 내로 로딩하기도 합니다.
템플릿 태그는 {% for %}나 {% if %} 태그를 가장 많이 사용.

{% for %} 태그
리스트에 담겨 있는 항목들을 순회하면서 출력할 수 있습니다.
<ul>
{% for athlete in athlete_list %}
    <li>{{ athlete.name }}</li>
<% endfor %>
</ul>
운동 선수 리스트에 들어있는 항목을 순회하면서 각 운동 선수의 이름을 보여주는 문장.
{% for %} 태그를 사용해 루프를 돌 때 사용할 수 있는 여러 가지의 변수를 제공하고 있습니다.
forloop.counter       현재까지 루프를 실행한 루프 카운트(1부터)
forloop.counter()     현재까지 루프를 실행한 루프 카운트(0부터)
forloop.revcounter    루프 끝에서 현재가 몇 번째인지 카운트한 숫자(1부터)
forloop.revcounter()  루프 끝에서 현재가 몇 번째인지 카운트한 숫자(0부터)
forloop.first         루프에서 첫 번째 실행이면 True 값을 가짐
forloop.last          루프에서 마지막 실행이면 True 값을 가짐
forloop.parentloop    중첩된 루프에서 현재의 루프 바로 상위의 루프를 의미함.

{% if %} 태그
변수를 평가하여 True이면 바로 아래의 문장이 표시됩니다.
{% if athlete_list %}
    Number of athletes:{{ athlete_list|length }}
{% elif athlete_in_locker_room_list %}
    Athletes should be out of the locker room soon!
{% else %}
    No athletes.
{% endif %}
만일 athlete_list 변수가 True이면 운동 선수 숫자가 표시되고, athlete_in_locker_room_list 변수가 True면 문장이 표시.
두 조건 모두 아니라면 No athletes.라는 문장이 표시.
{% if %} 태그에 필터와 연산자를 사용할 수 있습니다.
주의할 점은 대부분의 필터가 스트링을 반환하므로 산술 연산이 안되는데, length 필터는 예외적으로 가능.
{% if athlete_list|length > 1 %}
또한, {% if %} 태그에는 다른 연산도 가능합니다.
and, or, not, and not, ==, !=, <, >, <=, >=, in, not in

{% csrf_token %} 태그
POST 방식의 <form>을 사용하는 탬플릿 코드에서는 CSRF(Cross Site Request Forgery) 공격을 방지하기 위해 {% csrf_token %} 사용.
폼 데이터에는 악의적인 스크립트 문장이 들어있을 수도 있기 때문.
<form action="." method="post">{% csrf_token %}
위치는 <form> 엘리먼트의 첫 줄 다음에 넣어주면 됩니다.
이 태그를 사용하면 장고는 내부적으로 CSRF 토큰값의 유효성을 검증합니다.
검증에 실패하면 사용자에게 403 에러를 보여줍니다.
주의할 점은 CSRF 토큰값이 유출될 수도 있으므로, 외부 URL로 보내는 <form>에는 사용하지 않도록 합니다.

CSRF 공격이란?
사이트 간 요청 위조 공격이라고 표현. 웹 사이트의 취약점을 공격하는 방식 중의 하나로, 특정 웹 사이트에서 이미 인증을
받은 사용자를 이용하여 공격을 시도. 인증을 받은 사용자가 공격 코드가 삽입된 페이지를 열면 공격 대상이 되는 웹 사이트는
위조된 공격 명령이 믿을 수 있는 사용자로부터 발송된 것으로 판단하게 되어 공격을 받게 되는 방식.

{% url %} 태그
주 목적은 소스에 URL을 하드코딩하는 것을 방지하기 위한 것.
<form action="{% url 'polls:vote' question.id %}" method="post">
만일 이 태그를 사용하지 않는다면 URL을 하드코딩해야 합니다.
<form action="/polls/3/vote/" method="post">
하드 코딩한다면 /polls/라는 URL을 /blog/라고 변경하는 경우에 URLconf뿐만 아니라 모든 html을 찾아서 변경해줘야 하는 문제.
또한 /3/이라는 숫자는 런타임에 따라 결정되어 항상 변하는 값으로 변수처리를 해줘야 하기 때문에 불편.
이런 이유 때문에 하드코딩을 피하는 것.
{% url %}태그를 사용하면 URL이 변경되더라도 URLconf 만을 참조하여 원하는 URL을 추출할 수 있다.
{% url 'namespace:view-name' arg1 arg2 %}
namespace:urls.py파일의 include() 함수 또는 app_name 변수에 정의한 이름공간 이름
view-name:urls.py파일에서 정의한 URL 패턴 이름
argN:뷰 함수에서 사용하는 인자로, 없을 수도 있고 여러 개인 경우 빈칸으로 구분.
{% with %} 태그
특정 값을 변수에 저장해두는 기능을 합니다.
{% with total=business.employees.count %}
    {{ total }} people works at buisness
{% endwith %}
total 변수의 유효 범위는 with 구문 내, 즉 {% with %}에서 {% endwith %}까지 입니다.
데이터베이스를 조회하는 것처럼 부하가 큰 동작의 결과를 저장해 둠으로써, 다시 동일한 동작이 필요한 경우에는
저장해 둔 결과를 활용하여 부하를 줄이기 위한 태그.
{% with business.employees.count as total %}
    {{ total }} people works at buisness
{% endwith %}

{% load %} 태그
사용자 정의 태그 및 필터를 로딩해줍니다.
{% load somelibrary package.otherlibrary %}
태그 및 필터는 장고에서 기본적으로 제공하는 것 외에도, 개발자가 필요에 따라 스스로 정의하여 사용할 수 있다.
이런 것을 사용자 정의 태그, 사용자 정의 필터라고 합니다.
사용자 정의 태그 및 필터를 사용하기 위해서는 사용하기 전에 로딩을 먼저 해줘야 합니다.
위의 문장은 somelibrary.py 파일 및 package/otherlibrary.py 파일에 정의된 사용자 정의 태그 및 필터를 로딩해줌.

4.3.4 템플릿 주석
템플릿 코드에서도 주석문을 사용할 수 있습니다.
1)한 줄 주석문으로, {# #} 형식을 따릅니다.
한 문장의 전부 또는 일부를 주석 처리하는 방법.
{# greeting %}hello
greeting은 주석처리되고, hello 문구만 나타남.
{# #}안에 템플릿 코드가 들어있어도 정상적으로 주석 처리.
{# {% if foo %}bar{% else %} #}
2)여러 줄의 주석문으로, {% commemt %} 태그를 사용합니다.
{% comment "Optional note" %}
<p>Commented out text here</p>
{% endcomment %}
"Optional note"문구는 없어도 되지만, 왜 주석 처리를 하는지 사유를 기록해두면 나중에 기억하기 편리.
{% commemt %} 태그는 중첩하여 사용할 수 없다.

4.3.5 HTML 이스케이프
템플릿 코드를 랜더링하여 HTML 텍스트를 만들 때, 주의사항이 있습니다.
만일 템플릿 변수에 HTML의 태그가 들어있는 경우, 그대로 랜더링하면 원하지 않는 결과가 나올 수도 있습니다.
예를 들어 name 변수에 HTML 태그가 들어있는 상황에서
name = "<b>username"
Hello, {{ name }}
그 결과는
Hello, <b>username
이 결과는 웹 브라우저에 표시될 때 <b> 태그 이후의 문장을 모두 볼드체로 바꿔버리기 때문에, 당초 원했던 Hello, <b>username과
다른 결과가 나타납니다.
이런 약점을 이용하여 XSS(Cross Site Scripting} 공격이 이뤄집니다.)

XSS 공격이란?
사이트 간 스크립팅 공격이라고 표현합니다. 웹 사이트의 취약점을 공격하는 방식 중의 하나로, 웹 사이트 관리자가 아닌 일반
사용자라도 시도할 수 있는 공격 방법.
주로 여러 사용자가 보게 되면 전자 게시판에 악성 스크립트가 담긴 글을 올리는 형태.
이 취약점은 웹 애플리케이션이 사용자로부터 입력받은 값을 제대로 검사하지 않고 사용할 경우 나타납니다.

그래서 사용자가 입력한 데이터를 그대로 렌더링하는 것은 위험할 수 있습니다.
그래서 장고는 방지하기 위해 자동 이스케이프 기능을 제공하고 있습니다.
장고는 디폴트로 HTML에 사용되는 예약 문자들을 예약 의미를 제거한 문자로 변경해주는 기능을 제공합니다.
< (less than) 문자는 &lt; 로 변경함
> (greater than) 문자는 &gt; 로 변경함
'(single quote) 문자는 &#39; 로 변경함
"(double quote) 문자는 &quot; 로 변경함
&(ampersand) 문자는 &amp; 로 변경함
그러나 자동 HTML 이스케이프 기능을 비활성화시켜야 하는 경우도 발생합니다.
예를 들어, HTML 태그를 그대로 출력하고 싶은 경우나, 이스케이프 문자가 들어있는 이메일 메시지를 템플릿 파일에
출력하는 경우가 이에 해당.

장고의 자동 이스케이프 기능을 비활성화시키는 방법은
1)safe 필터를 사용하여 자동 이스케이프를 방지하는 방법입니다.
safe 필터는 템플릿 변수에만 영향을 미칩니다.
This will not be escaped:{{ date|safe }}
2){% autoescape %} 태그를 사용하여 자동 이스케이프를 방지하는 방법입니다.
이 경우는 템플릿 코드에서 범위를 정하여 이스케이프를 방지할 수 있다.
{% autoescape off %}
Hello {{ name }}
{% endautoescape %}
추가적으로, 필터의 인자에 사용되는 스트링 리터럴에는 자동 이스케이프 기능이 적용되지 않습니다.
그래서 첫 번째 문장보다는 두 번째 문장을 사용하는 것이 좋다.
{{ date|default:"3 < 5" }} //스트링 리터럴에서는 자동 이스케이프 안됨.
{{ date|default:" 3 &lt; 5" }}

4.3.6 템플릿 상속
상속은 템플릿 문법 중에서 가장 복잡하지만, 강력한 기능.
템플릿 상속을 통해서 템플릿 코드를 재사용할 수 있고, 사이트의 룩앤필을 일관성 있게 보여줄 수 있기 때문.
부모 템플릿은 템플릿의 뼈대를 만들어주고 {% block %} 태그를 통해 하위로 상속해줄 부분을 지정해주면, 자식 템플릿은 부모
템플릿의 뼈대는 그대로 재사용하고 {% block %} 부분만 채워주면 됩니다.

예를 들어, 부모 템플릿에 3개의 {% block %} 태그, title블록, sidebar 블록, content 블록을 지정한 경우.
<!DOCKTYPE html>
<html lang="en">
<head>
    <link rel="stylesheet" href="style.css"/>
    <title>{% block title %}My amazing site{% endblock %}</title>
</head>

<body>
    <div id="sidebar">
        {% block sidebar %}
        <ul>
            <li><a href="/">Home</a></li>
            <li><a href="/blog/">Blog</a></li>
        </ul>
        {% endblock %}
    </div>
    <div id="content">
        <% block content %}{% endblock %}
    </div>
</body>
</html>
자식 템플릿에서는 3개 중 2개를 채우는데 3개의 {% block %}를 모두 채울 필요는 없습니다.
sidebar 블록처럼 자식 템플릿에서 채우지 않으면 부모 템플릿 내용을 그대로 사용합니다.
상속을 받는다는 것을 표시하기 위해 {% etends %} 태그를 사용합니다.
{% extends "base.html" %}

{% block title %}My amazing blog{% endblock %}
{% block content %}
{% for entry in blog_entries %}
    <h2>{{ entry.title }}</h2>
    <p>{{ entry.body }}</p>
{% endfor %}
{% endblock %}
자식 템플릿 파일로, 부모 템플릿 코드로부터 상속을 받고 자식 템플릿 코드에서 렌더링한 결과는
<!DOCTYPE html>
<html lang="en">
<head>
    <link rel="stylesheet" href="style.css"/>
    <title>My amazing blog</title> //부모 템플릿의 title블록으로부터 상속받음. 오버라이딩됨.
</head>
<body>
    <div id="sidebar">
        //부모 템플릿의 sidebar 블록으로부터 상속받은 부분. 자식 템플릿에서 정의하지 않아 그대로 사용.
        <ul>
            <li><a href="/">Home</a></li>
            <li><a href="/blog/">Blog</a></li>
        </ul>
    </div>
    <div id="content">
        //부모 템플릿의 content 블록으로부터 상속받은 부분. 오버라이딩.
        <h2>Entry one</h2>
        <p>This is my first entry.</p>
        <h2>Entry two</h2>
        <p>This is my second entry.</p>
    </div>
</body>
</html>
템플릿 상속을 사용하면 템플릿 전체의 모습을 구조화할 수 있어 코드의 재사용이나 변경이 용이하고, UI의 룩앤필을 일관되게.
사이트 전체적으로 조화로운 룩앤필을 위해 일반적으로 템플릿 상속을 3단계로 사용하는 것을 권장.
1단계:사이트 전체의 룩앤필을 담고 있는 base.html을 만듭니다.
2단계:사이트 하위의 섹션별 스타일을 담고 있는 base_news.html, base_sports.html 등의 템플릿을 만듭니다.
그리고 base.html템플릿을 상속받습니다.
3단계:개별 페이지에 대한 템플릿을 만듭니다. 2단계 템플릿 중 적절한 템플릿을 상속받습니다.

상속을 정의할 때는 다음 사항을 유의해야 한다.
1){% extends %} 태그는 사용하는 태그 중에서 가장 먼저 나와야 합니다.
2)템플릿의 공통사항을 가능한 많이 뽑아 1단계 부모 템플릿에 {% block %} 태그가 많아질수록 좋습니다.
3)부모 템플릿의 {% block %} 안에 있는 내용을 그대로 사용하고 싶다면 자식 템플릿에서 {{ block.super }} 변수를 사용.
부모 템플릿의 내용을 그대로 사용하면서 자식 템플릿에서 내용을 추가하는 경우에 사용할 수 있다.
4)가독성을 높이기 위해 {% endblock content %} 처럼 블록명을 기입.

4.4 폼 처리하기
장고에서는 좀 더 간편하게 폼을 처리할 수 있는 기능을 제공합니다.

4.4.1 HTML에서의 폼
우리는 웹 사이트를 개발할 때 사용자로부터 입력을 받기 위해서 폼을 사용합니다.
HTML로 표현하면 폼은 <form>...</form> 사이에 있는 엘리먼트들의 집합입니다.
웹 사이트 사용자는 폼을 통해 텍스트를 입력할 수도 있고, 항목을 선택할 수도 있습니다.
폼에 입력된 데이터는 서버로 보내집니다.
텍스트 입력이나 체크 박스 등과 같은 간단한 폼의 엘리먼트들은 기본 위젯을 사용하지만, 달렷 위젯, 슬라이드 바 등의 복잡한
엘리먼트들은 자바 스크립트나 CSS를 사용하기도 합니다.
폼은 <input>엘리먼트 외에도 폼 데이터를 어디로 보낼지 지정해주는 action 속성과 어떤 HTTP 메소드로 보낼지 지정해주는 method속성.
HTTP 프로토콜 중 폼에서 사용할 수 있는 HTTP 메소드는 GET과 POST 뿐.
장고는 이 중에서도 폼의 데이터를 전송할 때는 POST 방식만을 사용.
서버 시스템의 상태를 바꾸는 요청, 데이터베이스의 내용을 변경하는 요청은 POST 방식을 사용.
시스템의 상태를 바꾸지 않는 요청에는 GET 방식을 사용.
GET 방식은 패스워드 폼에서도 사용하지 않도록 권유하는데, 이유는 패스워드가 URL이나 히스토리, 서버의 로그에 텍스트로 보일 수 있기에.
GET 방식은 폼 데이터가 많거나 이미지와 같은 2진 데이터를 보내는 경우에도 부적합하고 보안에도 취약하기 때문에 POST 사용.
추가적으로 장고는 보안을 강화하기 위하여 CSRF 방지 기능을 제공.
하지만 검색 폼 같은 경우에는 GET 방식이 적절한데, 데이터가 URL에 포함되서, URL을 북마크해 쉽게 공유하거나 재전송할 수 있기 때문.

4.4.2 장고의 폼 기능
웹 서버에서의 폼 처리는 복잡한 과정이지만, 공통적인 절차를 갖고 있습니다.
여러 가지 타입의 많은 위젯이 폼 화면 출력용으로 준비되어야 하고, HTML로 렌더링되며, 적절한 인터페이스를 사용하여
입력 및 수정되고, 서버로 보내져서 데이터가 유효한지 검증을 거친 후에 적절한 처리를 위해 저장되거나 전달됩니다.
장고는 이러한 폼 기능들을 단순화하고 자동화해서 개발자가 직접 코딩하는 것보다 훨씬 안전하게 처리해줍니다.
1)폼 생성에 필요한 데이터를 폼 클래스로 구조화하기
2)폼 클래스의 데이터를 랜더링하여 HTML 폼 만들기
3)사용자로부터 제출된 폼과 데이터를 수신하고 처리하기
폼이라는 용어는 HTML의 <form>을 지칭할 수도 있고, <form>을 만들어내는 장고의 Form 클래스일 수도 있고, 서버로
제출된 구조화된 데이터일 수도 있습니다.
가장 핵심적인 컴포넌트는 장고의 폼 클래스.
모델 클래스는 데이터베이스 테이블의 논리적인 구조 및 동작 기능, 우리에게 보여지는 방식들을 기술.
폼 클래스는 폼을 기술하고 폼이 어떻게 작동하고 어떻게 보이는지를 결정합니다.
모델 클래스의 필드가 데이터베이스의 필드로 매핑되듯이, 폼 클래스의 필드도 HTML 폼의 <input> 엘리먼트에 매핑.
필드는 폼 데이터를 저장하고 있으며, 폼이 제출되면 자신의 데이터에 대한 유효성 검사를 실시.
필드는 저장하는 데이터의 종류에 따라 자신의 타입을 가진다.
또한 폼의 필드는 브라우저에서 HTML 위젯으로 표현되고, 필드 타입마다 디폴트 위젯 클래스를 가지고 있으며 필요 시 오버라이딩.
장고에서는 DateField와 FileField라는 필드 타입을 제공하는데, DateField 타입은 날씨와 관련된 데이터를 다루고,
FileField 타입은 파일과 관련된 데이터를 다룹니다.
이 둘은 서로 다른 종류의 데이터를 처리할 뿐 아니라 유효성 검사 방식도 다르고, 디폴트 위젯 클래스도 다릅니다.
즉, 폼 클래스의 필드를 정할 때도 대상이 되는 데이터에 맞는 적절한 타입을 지정해줄 수 있어야 합니다.
폼도 템플릿의 일부이므로 템플릿 코드에 포함되어 렌더링 절차를 거칩니다.
장고에서 객체를 렌더링할 때는 3가지 과정.
1)렌더링할 객체를 뷰로 가져오기(예를 들어, 데이터베이스로부터 객체를 추출하기)
2)그 객체를 템플릿 시스템으로 넘겨주기
3)템플릿 문법을 처리해서 HTML 마크업 언어로 변환하기

폼도 객체이기 때문에 템플릿에서 폼을 랜더링하는 작업은 객체를 렌더링하는 것과 거의 동일하지만 추가적인 고려사항이 있다.
폼 객체에는 데이터가 없을 수도 있다는 고려를 해야 한다.
예를 들어, 모델 객체를 렌더링하는 경우에 데이터가 없는 빈 객체를 렌더링하는 경우는 매우 드물다.
하지만, 폼 객체는 렌더링 이후에 사용자가 데이터를 채우는 것이 보통이므로, 빈 객체를 렌더링을 자주 하게 된다.
즉, 폼 객체는 보통 뷰 함수에서 생성하는데, 뷰 함수에서 폼 객체를 생성할 때는 데이터 없이 만들 것인지, 아니면 데이터를
채워서 만들 것인지 적절히 구분해서 코딩해야 한다.
데이터를 채울 때는 저장된 모델 객체로부터 채울 수도 있고, 또는 직전에 제출된 HTML 폼으로부터 채울 수도 있습니다.
HTML로 채우면 폼 필드가 여러 개인 경우 하나의 필드에서 에러가 발생하여 다시 폼 데이터를 입력할 때 에러가 없는 다른 필드들은
직전에 제출된 폼으로부터 데이터를 채우고 사용자에게 보여주는 경우를 하나의 예로 들 수 있다.
데이터가 없는 폼을 unbound 폼이라고 하며, 언바운드 폼은 렌더링되어 사용자에게 보여질 때 비어있거나 디폴트 값으로 채워짐.
bound 폼은 제출된 데이터를 갖고 있어 데이터의 유효성 검사를 하는 데 사용됨.

4.4.3 폼 클래스로 폼 생성
요점은 폼도 클래스로 정의해서 간편하게 만들 수 있다는 것.
사용자의 이름을 취득하기 위해 간단한 폼.
<form action="/your-name/" method="post">
    <label for="your_name">Your name:</label>
    <input id="your_name" type="text" name="your_name" value="{{ current_name }}">
    <input type="submit" value="OK">
</form>
POST 방식을 이용해 브라우저에게 폼 데이터를 URL /your-name/으로 보내달라고 요청하고 있다.
{{ current_name }}템플릿 변수는 템플릿 렌더링을 요청하는 뷰에서 그 변수값을 지정해줄 것이다.
폼이 제출되면 POST 요청에 폼 데이터가 담겨서 서버로 보내집니다.
그리고 URL /your-name/에 해당하는 뷰가 있어, 요청 데이터에서 이름/값 쌍을 찾아서 뷰의 로직에 따라 적절한 처리를 한다.
장고는 <form> 엘리먼트의 기능을 제공하기 위해 폼 클래스를 정의합니다.
모든 폼 클래스는 django.forms.Form의 자식 클래스로 생성.
from django import forms
class NameForm(forms.Form):
    your_name = forms.CharField(label='Your name', max_length=100)
필드가 your_name 하나인 폼 클래스이고 label 속성도 정의했다.
이는 렌더링되면 <label> 엘리먼트로 나타날 것이다.
필드의 최대 길이도 max_length 속성으로 지정.
두 가지 기능이 있는데 하나는 HTML <input> 엘리먼트에 maxlength="100"이라는 문구를 넣어 사용자가 100글자 이상 입력하는 것을
브라우저가 방지할 수 있도록 해줍니다.
또 다른 하나는 장고가 브라우저로부터 폼 데이터를 받았을 때 데이터의 길이가 유효한지 검사하는데 사용됩니다.
각각의 폼 필드는 위젯 클래스를 갖고 있고, 위젯 클래스는 <input type="text">와 같은 HTML 폼 위젯으로 대응.
대부분의 폼 필드는 디폴트 위젯을 갖고 있습니다.
CharField필드 타입은 TextInput 위젯이 디폴트 위젯이며, HTML <input type="text">로 변환됩니다.
만일 디폴트 위젯을 <textarea>로 변경하려면 폼 필드를 정의할 때 명시적으로 지정.
your_name = forms.CharField(label='Your name', max_length=100, widget=forms.Textarea)
장고의 폼 클래스는 모든 필드에 대해 유효성 검사 루틴을 실행시키는 is_valid() 메소드를 갖고 있습니다.
이 메소드가 호출되어 유효성 검사를 하고, 그 결과 모든 필드가 유효하다면 is_valid() 메소드는 2가지 일을 합니다.
1)True를 반환.
2)폼 데이터를 cleaned_data 속성에 넣습니다.

폼 클래스가 템플릿 시스템에 의해 렌더링되면 결과가 다음과 같다.
<label for="your_name">Your name:</label>
<input id="your_name" type="text" name="your_name" maxlength="100">
렌더링 결과에 <form> 태그나 submit 버튼은 없는데 개발자가 직접 템플릿에 넣어줘야 합니다.
<form action="/your-name/" method="post">
    {% csrf_token %}
    {{ form }}
    <input type="submit" value="Submit"/>
</form>
CSRF 공격을 방지하기 위해 {% csrf_token %} 태그를 추가하고, 폼 클래스는 {{ form }} 변수로 사용.
{{ form }} 변수는 뷰에서 컨텍스트 변수에 포함하여 템플릿 시스템으로 넘겨주게 됩니다.

4.4.4 뷰에서 폼 클래스 처리
NameForm 폼 클래스와 name.html 템플릿을 사용해 폼을 보여주고 폼 데이터를 수신해 처리하는 뷰를 작성.
폼을 처리하는 뷰는 2개가 필요.
하나는 폼을 보여주는 뷰이고, 다른 하나는 제출된 폼을 처리하는 뷰.
2개의 뷰는 하나의 뷰로 통합하여 처리할 수 있는데, 장고에서는 하나의 뷰로 통합하여 폼을 처리하는 것을 권장.
2가지 기능을 처리하려면, 처음 사용자에게 보여주는 폼과 사용자가 데이터를 입력한 후 제출된 폼을 구분하여 처리해야 한다.
장고에서는 이를 HTTP 메소드로 구분합니다.
뷰가 GET 방식으로 요청을 받은 경우에는 사용자에게 처음으로 폼을 보여주도록 처리하고, 뷰가 POST 방식으로 요청을 받은 경우에는
담긴 제출된 폼으로 간주하여 처리하게 됩니다.
from django.shortcuts import render
from django.http import HttpResponseRedirect
def get_name(request): //뷰 함수 이름은 get_name()이고, request인자는 필수.
    # POST 방식이면, 데이터가 담긴 제출된 폼으로 간주.
    //요청 방식에 따라, GET과 POST요청을 구분하여 처리.
    //사용자가 폼에 데이터를 입력하고 제출하면 POST 요청으로 도착.
    if request.method == 'POST': 
        # request에 담긴 데이터로, 클래스 폼을 생성합니다.
        //폼이 POST 요청으로 제출되면 뷰는 다시 한 번 폼 객체를 생성하는데, 이번에는 요청에 포함된 데이터로 채워줍니다.
        //이러한 폼을 bound form이라고 합니다.
        form = NameForm(request.POST) 
        # 폼에 담긴 데이터가 유효한지 체크합니다.
        //만일 True이면 유효한 폼 데이터가 cleaned_data 속성에 담겨 있게 되고, 이 데이터를 사용하여 데이터베이스를
        //변경하거나 로직에 따라 다른 처리를 하게 됩니다.
        //그 이후에 브라우저에게 HTTP 리다이렉트를 전송하여 다음 페이지로 이동하게 됩니다.
        if form.is_valid(): 
            # 폼 데이터가 유효하면, 데이터는 cleaned_data로 복사.
            new_name = form.cleaned_data['name']
            # 로직에 따라 추가적인 처리를 합니다.
            # 새로운 URL로 리다이렉션시킵니다.
            return HttpResponseRedirect('/thanks/')
    # POS 방식이 아니라면(GET)
    # 빈 폼을 사용자에게 보여줍니다.
    //GET 요청이 도착하면 빈 폼 객체를 생성하고, 렌더링을 위해 템플릿 시스템으로 전달합니다.
    //이 부분이 사용자가 해당 URL을 처음 방문 시 일어나는 동작.
    else:
        form = NameForm()
    //만일 True가 아니면 render()를 호출합니다. 
    //이때 템플릿 시스템으로 전달되는 컨텍스트 변수 'form'에는 직전에 제출된 폼 데이터로 채워집니다.
    //HTTPResponseRedirect()를 리턴하는 경우가 아니면 이 라인이 실행됩니다.
    //render()함수는 템플릿 코드 name.html에 컨텍스트 변수를 적용하여 사용자에게 보여줄 최종 템플릿 파일을 만들고,
    //이를 담아서 HttpResponse 객체를 반환합니다.
    return render(request, 'name.html', {'form':form})

4.4.5 폼 클래스를 템플릿으로 변환
폼 클래스를 템플릿으로 변환하기 위해서는 폼 객체를 생성해서 이를 템플릿 시스템에 넘겨주면 됩니다.
템플릿 시스템에서는 템플릿 문법 및 폼 객체를 해석해서 HTML 템플릿 파일을 만들어줍니다.
{{ form }} 구문은 HTML의 <label>과 <input> 엘리먼트 쌍으로 렌더링 됩니다.
HTML <label>/<input> 쌍으로 변환 시, {{ form }} 이외에도 3가지 옵션이 더 있습니다.
{{ from.as_table }}:<tr> 태그로 감싸서 테이블 셀로 렌더링됩니다. {{ form }}과 동일
{{ form.as_p }}:<p> 태그로 감싸도록 렌더링됩니다.
{{ form.as_ul }}:<li> 태그로 감싸도록 렌더링됩니다.
<label>/<input> 태그 쌍을 감싸는 <table> 이나 <ul> 태그는 개발자가 직접 추가해야 합니다.
<form> 태그와 submit 컨트롤도 자동으로 추가되지 않으므로 개발자가 직접 작성해야 합니다.
from django import forms
class ContactForm(forms.Form):
    subject = forms.CharField(max_length=100)
    message = forms.CharField(widget=forms.Textarea)
    sender = forms.EmailField()
    cc_myself = forms.BooleanField(required=False)
{{ form.as_p }} 옵션으로 변환하는 경우, 그 결과 템플릿 파일은
<p><label for="id_subject">Subject:</lable>
    <input id="id_subject" type="text" name="subject" maxlength="100"/></p>
<p><label for="id_message">Message:</label>
    <input type="text" name="message" id="id_message"/></p>
<p><label for="id_sender">Sender:</label>
    <input type="email" name="sender" id="id_sender"/></p>
<p><label for="id_cc_myself">Cc myself:</label>
    <input type="checkbox" name="cc_myself" id="id_cc_myself"/></p>
폼 클래스의 각 타입에 따라 <input type>태그 타입이 변환됩니다.
<label> 태그에 나타나는 텍스트는 각 필드를 정의할 때 명시적으로 지정할 수 있습니다.
위 예제에서는 디폴트 레이블 텍스트를 사용했다.
디폴트 레이블 텍스트는 필드명에서 첫 자를 대문자로 하고 밑줄(_)은 빈칸()으로 변경하여 만듭니다.
<input id> 태그 속성도 각 필드의 필드명을 사용하여 id_필드명 형식으로 만듭니다.
이것은 <label for> 태그 속성에도 사용됩니다.

4.5 클래스형 뷰
뷰는 요청을 받아서 응답을 반환해주는 호출 가능한 객체입니다.
장고에서는 뷰를 함수로도 작성할 수 있고 클래스로도 작성할 수 있습니다.
함수형 뷰보다 클래스형 뷰가 장점이 많습니다.
클래스형 뷰를 사용하면 상속과 믹스인 기능을 사용해서 코드를 재사용할 수 있고, 뷰를 체계적으로 구성할 수도 있다.
그리고 제네릭 뷰 역시 클래스형 뷰로 작성되어 있습니다.
간단한 경우에는 함수형 뷰로 신속하게 개발하는 것도 방법이지만, 로직이 복잡해지고 프로젝트가 커질수록 클래스형 뷰.

4.5.1 클래스형 뷰의 시작점
클래스형 뷰를 사용하기 위해서는 가장 먼저 URLconf에서 함수형 뷰가 아닌 클래스형 뷰를 사용한다는 점을 표시해야 한다.
예를 들어, MyView라는 클래스형 뷰를 사용한다면 URLconf는 urls.py에서
from django.urls import path
from myapp.views import MyView
urlpatterns = [
    path('about/', MyView.as_view()),
]
장고의 URL 해석기는 요청과 관련된 파라미터들을 클래스가 아닌 함수에 전달하기 때문에 클래스형 뷰는 클래스로
진입하기 위한 as_view() 클래스 메소드를 제공합니다.
이 메소드를 진입 메소드라고 부릅니다.
as_view() 진입 메소드의 역할은 클래스의 인스턴스를 생성하고, 그 인스턴스의 dispath() 매소드를 호출.
dispatch() 메소드는 요청을 검사해서 GET, POST 등의 어떤 HTTP 메소드로 요청되었는지를 알아낸 다음, 인스턴스 내에서
해당 이름을 갖는 메소드로 요청을 중계해줍니다.
만일 해당 메소드가 정의되어 있지 않으면 HttpResponseNotAllowed 익셉션을 발생.
MyView클래스를 views.py에서 코딩하면
from django.http import HttpResponse
from django.views.generic import View
class MyView(View):
    def get(self, request):
        # 뷰 로직 작성
        return HttpResponse('result')
as_view()라는 메소드는 장고에서 기본적으로 제공.
dispatch()메소드도 명시적으로 정의해주지 않아도 장고에서 기본적으로 제공.
MyView클래스는 View 클래스를 상속받고 있으며, View 클래스에는 as_view()메소드와 dispatch()메소드가 정의.
그래서 MyView클래스에서는 이 메소드들을 정의하지 않아도 사용할 수 있는 것.

4.5.2 클래스형 뷰의 장점 - 효율적인 메소드 구분
함수형 뷰와 비교할 때 클래스형 뷰의 장점
1)GET, POST 등의 HTTP 메소드에 따른 처리 기능을 코딩할 때, IF 함수를 사용하지 않고 메소드명으로 구분할 수 있으므로
코드의 구조가 깔끔.
2)다중 상속과 같은 객체 지향 기술이 가능하므로, 클래스형 제네릭 뷰 및 믹스인 클래스 등을 사용할 수 있고,
코드의 재사용성이나 개발 생산성을 획기적으로 높여줍니다.

함수형 뷰에서 GET 메소드를 처리하는 로직을 작성한다면
from django.http import HttpResponse
def my_view(request):
    if request.method == 'GET':
        # 뷰 로직 작성
        return HttpResponse('result')
요청 request 객체의 method 속성을 체크하는 로직이 필요하므로, 항상 if 조건의 체크 문장이 필요.
반면 클래스형 뷰로 작성하면 구조가 깔끔.
from django.http import HttpResponse
from django.views.generic import View
class MyView(View):
    def get(self, request):
        # 뷰 로직 작성
        return HttpResponse('result')
클래스형 뷰에서는 HTTP 메소드 이름으로 클래스 내에 메소드를 정의하면 됩니다.
메소드명은 소문자로 해야 하므로 get(), post(), head()과 같이.
클래스형 뷰에는 내부적으로 dispatch() 메소드가 있기 때문에 dispatch() 메소드가 GET, POST 등의 어떤 HTTP 메소드로
요청되었는지를 알아낸 다음 해당 이름을 갖는 메소드로 요청을 중계해줘서 가능하다.

예를 들어, HEAD HTTP 메소드로 서점에 방문한 직후에 새롭게 출간된 책이있는지를 서버에게 문의하는 용도.
최근 발간된 책이 없는데도 책 리스트를 서버로부터 받아오면 네트워크 대역폭이 낭비되므로 HEAD 메소드를 사용한 것.
HTTP 프로토콜 규격에 따르면 HEAD 효청에 대한 응답은 바디 없이 헤더만 보내주면 됩니다. views.py에서
from django.http import HttpResponse
from django.views.generic import ListView
from books.models import Book
class BookListView(ListView):
    model = Book
    
    def head(self, *args, **kwargs):
        last_book = self.get_queryset().latest('publication_date')
        response = HttpResponse('')
        # RFC 1123 date 포맷
        response['Last-Modified'] = last_book.publication_date.strftime('%a, %d %b %Y %H:%M:%S GMT')
        return response

4.5.3 클래스형 뷰의 장점 - 상속 기능 가능
상속 기능을 이해하려면 제네릭 뷰에 대해 알고 있어야 합니다.
클래스형 뷰의 대부분은 장고가 제공해주는 제네릭 뷰를 상속받아 작성하기 때문.
장고에서는 제네릭 뷰가 뷰 개발 과정에서 개발자의 단순 반복 작업을 덜어주는 기능입니다.
제네릭 뷰는 뷰 개발과정에서 공통적으로 사용할 수 있는 기능들을ㅇ 추상화하고, 이를 장고에서 미리 만들어 기본적으로
제공해주는 클래스형 뷰.
뷰가 클래스이기 때문에 상속 기능이 가능한 것이고, 작성한 클래스형 뷰를 상속받아 또 다른 클래스형 뷰를 작성할 수 있으므로
확장성도 증가합니다.

제네릭 뷰를 상속받아 클래스형 뷰를 작성하는 예제.
/about/이라는 URL로 웹 요청이 들어오면, 단순하게 about.html 템플릿을 보여준다.
# some_app/urls.py
from django.urls import path
from some_app.views import AboutView
urlpatterns = [
    path('about/', AboutView.as_view()),
]
# some_app/views.py
from django.views generic import TemplateView
class AboutView(TemplateView):
    template_name = "about.html"
urls.py 파일에서는 클래스형 뷰의 as_view() 메소드를 호출하도록 하였습니다.
장고가 제공해주는 TemplateView라는 제네릭 뷰를 상속받아 사용해 간단히 할 수 있다.
요청 request 객체를 분석하고, 템플릿 시스템에 넘겨줄 컨텍스트 변수를 구성하는 것은 모두 TemplateView 제네릭 뷰에서 처리.
그래서 간단하게 about.html 템플릿 파일을 사용하라고만 알려주면 된다.
조금 다른 방식으로 TemplateView 제네릭 뷰를 사용할 수도 있습니다.
urls.py 파일에서 about.html 템플릿 파일을 지정해주면 views.py 파일에 클래스형 뷰를 작성하는 것도 불필요해집니다.
그래서 그냥 URLconf만 작성하면 끝.
# some_app/urls.py
from django.urls import path
from django.views.generic import TemplateView
urlpatterns = [
    path('about/', TemplateView.as_view(template_name="about.html")),
]
TemplateView는 뷰에 특별한 로직이 없고, URL에 맞춰 해당 템플릿 파일의 내용만 보여줄 때 사용하는 제네릭 뷰.
중요한 것은 상속 기능과 더불어 중요한 기능으로 손꼽히는 오버라이딩 기능이 포함되어있다.
template_name은 TemplateView 클래스에 정의되어 있는 클래스 속성.
이런 클래스 속성을 필요에 따라 오버라이딩하여 사용할 수 있다는 것.
또한 AboutView클래스에서 오버라이딩할 수도 있고, as_view()메소드를 통해 오버라이딩할 수 있다.

4.5.4 클래스형 제네릭 뷰
장고에서는 URL 패턴으로부터 파라미터를 추출하고 그 파라미터로 데이터베이스를 검색하여 해당 데이터를 템플릿 시스템에서 렌더링하는
기능처럼, 웹 프로그램 개발 시 공통적으로 사용할 수 있는 로직을 이미 개발해 놓고 기본 클래스로 제공하고 있기 때문에
이를 상속받아 사용하면 된다.
장고에서는 이렇게 공통된 로직을 미리 개발해 놓고 제공하는 뷰를 제네릭 뷰라고 부른다.
제네릭 뷰는 클래스형 뷰로 구성되어 있다.
장고에서 제공하는 제네릭 뷰는 4가지로 분류할 수 있습니다.
Base View:뷰 클래스를 생성하고, 다른 제네릭 뷰의 부모 클래스를 제공하는 기본 제네릭 뷰입니다.
Generic Display View:객체의 리스트를 보여주거나, 특정 객체의 상세 정보를 보여줍니다.
Generic Edit View:폼을 통해 객체를 생성, 수정, 삭제하는 기능을 제공합니다.
Generic Date View:날짜 기반 객체의 연/월/일 페이지로 구분해서 보여줍니다.

제네릭 뷰 분류         제네릭 뷰 이름      뷰의 기능 또는 역할
Base View             View               가장 기본이 되는 최상위 제네릭 뷰. 다른 모든 제네릭 뷰는 View의 하위 클래스.
                      TemplateView       템플릿이 주어지면 해당 템플릿을 렌더링해줍니다.
                      RedirectView       URL이 주어지면 해당 URL로 리다이렉트시켜줍니다.
Generic Display View  ListView           조건에 맞는 여러 개의 객체를 보여줍니다.
                      DetailView         객체 하나에 대한 상세한 정보를 보여줍니다.
Generic Edit View     FormView           폼이 주어지면 해당 폼을 보여줍니다.
                      CreateView         객체를 생성하는 폼을 보여줍니다.
                      UpdateView         기존 객체를 수정하는 폼을 보여줍니다.
                      DeleteView         기존 객체를 삭제하는 폼을 보여줍니다.
Generic Date View     ArchiveIndexView   조건에 맞는 여러 개의 객체 및 그 객체들에 대한 날짜 정보를 보여줍니다.
                      YearArchiveView    연도가 주어지면 그 연도에 해당하는 객체들을 보여줍니다.
                      MonthArchiveView   연, 월이 주어지면 그에 해당하는 객체들을 보여줍니다.
                      WeekArchiveView    연도와 주차가 주어지면 그에 해당하는 객체들을 보여줍니다.
                      DayArchiveView     연, 월, 일이 주어지면 그 날짜에 해당하는 객체들을 보여줍니다.
                      TodayArchiveView   오늘 날짜에 해당하는 객체들을 보여줍니다.
                      DateDetailView     연, 월, 일, 기본키(또는 슬러그)가 주어지면 그에 해당하는 특정 객체 하나에
                                         대한 상세한 정보를 보여줍니다.

4.5.5 클래스형 뷰에서 폼 처리
유효하지 않은 폼 데이터를 수신할 수도 있으므로, 폼처리과정을 3가지로 구분.
1)최초의 GET:사용자에게 처음으로 폼(빈 폼이나 초기 데이터로 채워진 폼)을 보여줌
2)유효한 데이터를 가진 POST:데이터를 처리함, 주로 리다이렉트 처리됨.
3)유효하지 않은 데이터를 가진 POST:보통은 에러 메시지와 함께 폼이 다시 출력됨.
장고는 이러한 폼 처리 과정을 FormView라는 제네릭 뷰로 제공하고 있다.
함수형 뷰로 폼을 처리하면
from django.http import HttpResponseRedirect
from django.shortcuts import render
from .forms import MyForm
def myview(request):
    if request.method == "POST":
        form = MyForm(request.POST)
        if form.is_valid():
            # cleaned_data로 관련 로직 처리
            return HttpResponseRedirect('/success/')
    else:
        form = MyForm(initial={'key':'value'})
    return render(request, 'form_template.html',{'form':form})
IF 문장으로 HTTP의 GET방식과 POST 방식을 구부하여 뷰가 GET 방식으로 요청을 받은 경우에는 사용자에게 처음으로 폼을 보여주도록
처리하고, 뷰가 POST 방식으로 요청을 받은 경우에는 데이터가 담긴 제출된 폼으로 간주하여 처리하는 방식.
클래스형 뷰로 코딩하면
from django.http import HttpResponseRedirect
from django.shortcuts import render
from django.views.generic import View
from .forms import MyForm
class MyFormView(View):
    form_class = MyForm
    initial = {'key':'value'}
    template_name = 'form_template.html'
    def get(self, request, *args, **kwargs): //최초의 GET
        form = self.form_class(initial=self.initial)
        return render(request, self.template_name, {'form':form})
    def post(self, request, *args, **kwargs):
        form = self.form_class(request.POST)
        if form.is_valid():
            # cleaned_data로 관련 로직 처리
            return HttpResponseRedirect('/success/') //유효한 데이터를 가진 POST
        return render(request, self.template_name, {'form':form}) //유효하지 않은 데이터를 가진 POST
클래스형 뷰에서는 HTTP의 GET 방식과 POST 방식을 클래스 내의 메소드로 구분하여 처리함으로써, 구조가 깔끔.

위에서는 View 제네릭 뷰를 상속하여 작성하였지만, 폼 처리용 제네릭 뷰인 FormView를 상속받아 처리하면 훨씬 간결.
form .forms import MyForm
form django.views.generic.edit import FormView
class MyFormView(FormView):
    form_class = MyForm
    template_name = 'form_template.html'
    success_url = '/thanks/'

    def form_valid(self, form):
        # cleaned_data로 관련 로직 처리
        return super(MyFormView, self).form_valid(form)
FormView 제네릭 뷰를 사용하면 FormView 클래스에 이미 정의되어 있기 떄문에 클래스 내에 get(), post() 메소드 정의도 불필요.
하지만 4가지 사항을 유의하여 코딩해야 한다.
1)form_class:사용자에게 보여줄 폼을 정의한 forms.py 파일 내의 클래스명
2)template_name:폼을 포함하여 렌더링할 템플릿 파일 이름
3)success_url:MyFormView처리가 정상적으로 완료되었을 때 리다이렉트시킬 URL
4)form_valid()함수:유효한 폼 데이터로 처리할 로직 코딩. super() 함수를 사용하면 success_url로 지정된 URL로 리다이렉션 처리됨.

4.6 로그 남기기
장고의 로깅은 기본적으로 파이썬의 로깅 체계를 그대로 따르면서 일부만 추가.
파이썬의 로깅 모듈을 보면 로거, 핸들러, 필터, 포맷터 4가지 주요 컴포넌트를 정의하고 있습니다.
장고의 runserver나 웹 서버에 의해 장고가 실행될 때 장고는 settings.py파일에 정의된 LOGGING_CONFIG, LOGGING 항목을 참고하여
로깅에 관련된 설정을 처리합니다.
settings.py 파일에 관련 항목이 없더라도 디폴트 로깅 설정으로 처리됩니다.
따라서 장고의 로깅은 실행되는 시점부터 작동하여 로그가 출력됩니다.
또는 적절한 로거만 획득하면 우리가 원하는 로그를 기록하는 것이 가능.

Logging 주요 컴포넌트 관계
                 |Filter->Filter->Filter| 필터 체인 가능. Logger나 Handler 양쪽에 적용 가능.
                        ↙      ↘ 
Logger───────────────────────┬─────→Handle←------Formatter
한 개의 Logger에 여러 개의    └─────→Handle←------Formatter
Handler를 지정 가능함

4.6.1 로거
Logger는 로깅 시스템의 시작점으로, 로그 메시지를 처리하기 위해 메시지를 담아두는 저장소.
모든 로거는 이름을 가지고 있습니다.
로거는 로그 레벨을 갖게 되는데, 로그 메시지의 중요도에 따라 어느 레벨 이상의 메시지를 처리할지에 대한 기준.

로그레벨    정수값  설명
NOTSET      0      로그 레벨의 최하위 수준. 로거 또는 핸들러가 생성될 때 별도 설정이 없으면 갖는 디폴트 로그 레벨
DEBUG       10     디버그 용도로 사용되는 정보
INFO        20     일반적이고 보편적인 정보
WARNING     30     문제점 중에서 덜 중요한 문제점이 발생 시 이에 대한 정보
ERROR       40     문제점 중에서 주요 문제점이 발생 시 이에 대한 정보
CRITICAL    50     치명적인 문제점이 발생 시 이에 대한 정보. 로그 레벨의 최상위 수준.

로거에 저장되는 메시지를 로그 레코드라고 하며, 로그 레코드도 메시지의 심각성을 나타내는 로그 레벨을 가진다.
로그 레코드는 로그 이벤트에 대한 메타 정보도 가질 수 있는데, 스택 트레이스 정보나 에러 코드 등을 담을 수 있다.
메시지가 로거에 도착하면, 로그 레코드의 로그레벨과 로거의 로그 레벨을 비교합니다.
로그 레코드의 로그 레벨이 로거 자체의 로그 레벨과 같거나 그보다 높으면 메시지 처리를 계속 진행하고,
더 낮으면 그 메시지는 무시됩니다.
이렇게 로그 레코드와 로거의 로그 레벨을 비교하여 메시지 처리를 진행하는 것으로 결정되면 로거는 메시지를 핸들러에게 넘김.

4.6.2 핸들러
로거에 있는 메시지에 무슨 작업을 할지 결정하는 엔진.
즉, 메시지를 화면이나 파일 또는 네트워크 소켓 등 어디에 기록할 것인지와 같은 로그 동작을 정의.
핸들러도 로그 레벨을 가지고 있습니다.
로그 레코드의 로그 레벨이 핸들러의 로그 레벨보다 더 낮으면 핸들러는 메시지를 무시합니다.
로거는 핸들러를 여러 개 가질 수 있고, 각 핸들러는 서로 다른 로그 레벨을 가질 수 있습니다.
그래서 메시지의 중요도에 따라 다른 방식의 로그 처리가 가능.
예를 들어 ERROR 또는 CRITICAL 메시지는 표준 출력으로 보내는 핸들러를 하나 만들고, 차후 분석을 통해 ERROR 및 CRITICAL
메시지를 포함한 모든 메시지를 파일에 기록하는 또 다른 핸들러를 만들 수도 있습니다.

4.6.3 필터
로그 레코드가 로거에서 핸들러로 넘겨질 때, 필터를 사용해서 로그 레코드에 추가적인 제어를 할 수 있습니다.
기본 제어 방식은 로그 레벨을 지정하여 그 로그 레벨에 해당되면 관련 로그 메시지를 처리하는 것.
필터를 적용하면 로그 처리 기준을 추가할 수 있습니다.
예를 들어, 필터를 추가하여 ERROR 메시지 중에서 특정 소스로부터 오는 메시지만 핸들러로 넘길 수 있습니다.
필터를 사용하면 로그 레코드를 보내기 전에 수정하는 것도 가능합니다.
예를 들어 어떤 조건에 맞으면 ERROR 로그 레코드를 WARING 로그 레벨로 낮춰주는 필터를 만들 수도 있다.
필터는 로거 또는 핸들러 어디에나 적용이 가능하고, 여러 개의 필터를 체인 방식으로 동작시킬 수도 있다.

4.6.4 포맷터
로그 레코드는 최종적으로 텍스트로 표현되는데, 포멧터는 텍스트로 표현 시 사용할 포맷을 지정해줍니다.
포맷터는 보통 파이썬의 포맷 스트링을 사용하지만, 사용자 정의 포맷터도 만들 수 있습니다.

4.6.5 로거 사용 및 로거 이름 계층화
로그를 기록하기 위해서는 로거, 핸들러, 필터, 포맷터 등을 설계한 후에, 코드 내에서 로깅 메소드를 호출하면 됩니다.
# mysite/settings.py
LOGGING = {
    'version':1,
    'disable_existing_loggers':False,
    'handlers':{
        'console':{
            'class':'logging.StreamHandler.',
        },
    },
    'loggers':{
        'mylogger':{
            'handlers':['console'],
            'level':'INFO'
        },
    },
}
장고에서 로깅 설정은 settings.py 파일에 작성합니다.
로그 메시지를 기록하기 위해, 로거를 취득하고 적절한 위치에서 로깅 메소드를 호출하면 됩니다.
# some_app/views.py
# 파이썬의 로깅 모듈을 임포트
import logging
# settings.py 파일에서 설정된 로거를 취득함
logger = logging.getLogger('mylogger')
def my_view(request, arg1, arg):
    # 필요한 로직
    if bad_mojo:
        # ERROR 레벨의 로그 레코드를 생성함
        logger.error('Something went wrong!')
logging.getLogger()메소드를 호출하면 로거 객체를 얻을 수 있습니다.
로거 객체는 이름을 가지며, 로거를 계층화할 때 이름으로 각 로거를 구분합니다.
관행적으로 로거 이름에 __name__ 구문을 사용하는데, 이는 이 구문이 있는 파일의 파이썬 모듈 경로를 말합니다.
만일 ch3/polls/views.py 파일에서 구문을 사용한다면 __name__변숙밧은 polls.views가 됩니다.
로깅 호출을 모듈 단위로 처리할 수 있어서 많이 사용하는 구문.
모듈 단위로 로그를 기록하고 싶으면 로거를 구분하는 이름을 도트(.)방식으로 명명해주면 됩니다.
# 로거 이름으로 계층화
logger = logging.getLogger('project.interesting.stuff')
도트 방식의 로거 이름은 계층화를 이룹니다.
즉, project.interesting.stuff 로거의 부모는 project.interesting 로거이고, project.interesting 로거의 부모는 project로거.
로거의 이름을 빈 문자열('')로 지정하면 파이썬의 최상위 로거(루트 로거)가 됩니다.
로거의 계층화가 중요한 이유는 로깅 호출은 부모 로거에게 전파되기 때문.
그러면 로거 트리의 최상단 로거에서 핸들러 하나만을 만들어도 하위 로거의 모든 로깅 호출을 잡을 수 있습니다.
project 이름 공간에 정의된 로그 핸들러는 project.interesting 로거 및 project.interesting.stuff 로거가 보내주는 모든
로그 메시지를 잡을 수 있습니다.
로깅 호출의 전파는 로거 단위로 제어할 수 있는데, 특정 로거에서 상위 로거에 전파되는 것을 원하지 않으면 전파 기능을 
비활성화시킬 수도 있습니다.
로거 객체는 각 로그 레벨별로 로깅 호출 메소드를 갖고 있습니다.
logger.debug():DEBUG 레벨의 로그 레코드를 생성합니다.
logger.info():INFO 레벨의 로그 레코드를 생성합니다.
logger.warning():WARNING 레벨의 로그 레코드를 생성합니다.
logger.error():ERROR 레벨의 로그 레코드를 생성합니다.
logger.critical():CRITICAL 레벨의 로그 레코들르 생성합니다.
logger.log():원하는 로그 레벨을 정해서 로그 메시지를 생성합니다.
logger.exception():익셉션 스택 트레이스 정보를 포함하는 ERROR 레벨의 로그 메시지를 생성합니다.

4.6.6 장고의 디폴트 로깅 설정
로깅 메소드를 호출했을 때 로그 메시지를 원하는 대로 기록하기 위해서는 로거, 핸들러, 필터, 포맷터 등을 설정해야 한다.
파이썬의 로깅 라이브러리는 다양한 설정 방식을 제공하고 있는데, 장고는 사전형 설정(dictConfig)방식을 디폴트로 사용.
이 방식은 settings.py 파일의 LOGGING 항목에, 로깅 속성을 사전 형식으로 정의하게 됩니다.
이러한 설정에는 로거, 핸들러, 필터, 포맷터에 대한 정의뿐만 아니라, 각 컴포넌트의 로그 레벨과 같은 속성들도 정의합니다.
settings.py 파일에 LOGGING 항목을 지정하지 않으면 장고는 디폴트 로깅 설정을 사용합니다.
로깅 설정을 할 때, 이러한 디폴트 로깅 설정을 유지할 수도 있고, 디폴트 설정을 무시하고 새로 로깅 설정을 할 수도 있다.
디폴트 로깅 설정
# site-packages/django/utils/log.py
DEFAULT_LOGGING = {
    'version':1, //설정이 dictConfig version 1 형식.
    //기존의 로거들을 비활성화하지 않습니다. 이전 버전과의 호환성을 위한 항목으로, 디폴트는 True이며, True로 유지하면
    //기존 로거들을 비활성화합니다. 비활성화의 의미는 로거들을 삭제하는 것이 아닌 동작만을 중지시키는 것.
    //따라서 장고에서는 이 항목을 False로 사용하도록 권장.
    'disable_existing_loggers':False,
    //필터 2개를 정의
    'filters':{
        //이 필터는 DEBUG=False인 경우만 핸들러가 동작하도록 합니다.
        //특별키 ()의 의미는, 필터 객체를 생성하기 위한 클래스를, 파이썬이 아닌 장고에서 별도로 정의.
        'require_debug_false':{
            '()':'django.utils.log.RequireDebugFalse',
        },
        //이 필터는 DEBUG=True인 경우만 핸들러가 동작하도록 합니다.
        //특별키 ()의 의미는, 필터 객체를 생성하기 위한 클래스를, 파이썬이 아닌 장고에서 별도로 정의.
        'require_debug_true':{
            '()':'django.utils.log.RequireDebugTrue',
        },
    },
    //포맷터 1개를 정의.
    'formatters':{
        //이 포맷터는 로그 생성 시각과 로그 메세지만을 출력합니다.
        //틀별키 ()의 의미는 포맷터 객체를 생성하기 위한 클래스를 별도로 정의했다는 것을 알려줌.
        'django.server':{
            '()':'django.utils.log.ServerFormatter',
            'format':'[%(server_time)s] %(message)s',
        },
    },
    //3개의 핸들러를 정의.
    'handlers':{
        //이 핸들러는 INFO 레벨 및 그 이상의 메시지를 표준 에러로 출력해주는 StreamHandler 클래스를 사용.
        //이 핸들러는 require_debug_true 필터를 사용.
        'console':{
            'level':'INFO',
            'filters':['require_debug_true'],
            'class':'logging.StreamHandler',
        },
        //이 핸들러는 INFO 레벨 및 그 이상의 메시지를 표준 에러로 출력해주는 StreamHandler 클래스를 사용.
        //이 핸들러는 django.server 포맷터를 사용합니다.
        //django.server 로거에서 이 핸들러를 사용합니다.
        'django.server':{
            'level':'INFO',
            'class':'logging.StreamHandler',
            'formatter':'django.server',
        },
        //이 핸들러는 ERROR 및 그 이상의 로그 메시지를 사이트 관리자에게 이메일로 보내주는 AdminEmailHandler 클래스를 사용.
        //이 핸들러는 require_debug_false 필터를 사용.
        'mail_admins':{
            'level':'ERROR',
            'filters':['require_debug_false'],
            'class':'django.utils.log.AdminEmailHandler'
        },
    },
    //2개의 로거를 정의합니다.
    'loggers':{
        //이 로거는 INFO 및 그 이상의 로그 메시지를 console 및 mail_admins 핸들러에게 보냅니다.
        //django.*계층 즉, django 패키지의 최상위 로거입니다.
        'django':{
            'handlers':['console','mail_admins'],
            'level':'INFO',
        },
        //이 로거는 INFO 레벨 및 그 이상의 메시지를 django.server 핸들러에게 보냅니다.
        //상위 로거로 로그 메시지를 전파하지 않습니다.
        //이 로거는 장고의 개발용 웹 서버인 runserver에서 사용하는 로거.
        //5XX 응답은 ERROR 메시지로, 4XX 응답은 WARNING 메시지로, 그 외는 INFO 메시지로 출력.
        'django.server':{
            'handlers':['django.server'],
            'level':'INFO',
            'propagate':False,
        },
    },
}
디폴트 설정 내용은
만일 DEBUG=True이면, django.* 계층에서 발생하는 로그 레코드는 INFO 레벨 이상일 때 콘솔로 보내집니다.
만일 DEBUG=False이면, django.* 계층에서 발생하는 로그 레코드는 ERROR 레벨 이상일 때 관리자에게 이메일 전송됩니다.
django.server 로거는 DEBUG 값에 무관하게 로그 레코드가 INFO 레벨 이상이면 콘솔로 보냅니다. django.* 계층의 다른 로거들과
다르게 django 로거는 전파하지 않습니다.

4.6.7 장고의 로깅 추가 사항 정리
장고 패키지에는 몇 가지가 더 추가되었습니다.
1)django 로거:INFO 및 그 이상의 로그 메시지를 console 및 mail_admins 핸들러에게 보냅니다. django 패키지의 최상위 로거.
2)django.request 로거:요청 처리와 관련된 메시지를 기록합니다. 5XX 응답은 ERROR 메시지로, 4XX 응답은 WARNING 메시지로 발생.
이 로거에 담기는 메시지는 2개의 추가적인 메타 항목을 가집니다.
-status_code:HTTP 응답 코드
-request:로그 메시지를 생성하는 요청 객체
3)django.server 로거:INFO 레벨 및 그 이상의 메시지를 django.server 핸들러에게 보냅니다. 상위로거로 로그 메시지를 전파하지
않습니다. 이 로거는 장고의 개발용 웹 서버인 runserver에서 사용하는 로거입니다.
5XX 응답은 ERROR 메시지로, 4XX 응답은 WARNING 메시지로, 그 외에는 INFO 메시지로 출력.
4)django.template 로거:템플릿을 렌더링하는 과정에서 발생하는 로그 메시지를 기록합니다.
5)django.db.backends 로거:데이터베이스와 관련된 메시지를 기록합니다. 예를 들어, 애플리케이션에서 사용하는 모든 SQL 문장들이
이 로거에 DEBUG 레벨로 기록됩니다. 이 로거에 담기는 메시지는 추가적인 메타항목을 가집니다. 성능상의 이유로 SQL 로깅은
settings.DEBUG 항목이 True인 경우만 활성화됩니다.
-duration:SQL 문장을 실행하는 데 걸린 시간
-sql:실행된 SQL 문장
-params:SQL 호출에 사용된 파라미터
6)django.security.* 로거:사용자가 보안 측면에서 해를 끼칠수 있는 동작을 실행한 경우, 이에 대한 메시지를 기록.
예를 들어 HTTP Host 헤더가 ALLOWED_HOSTS에 없다면 장고는 400 응답을 리턴하고, 에러 메시지가
django.security.DisallowedHost 로거에 기록됩니다.
7)django.db.backends.schema 로거:데이터베이스의 스키마 변경 시 사용된 SQL 쿼리를 기록합니다.
추가된 핸들러는 1개.
1)AdminEmailHandler:ERROR 및 그 이상의 로그 메시지를 사이트 관리자에게 이메일로 보내주는 클래스.
추가된 필터는 3개.
1)CallBackFilter:이 필터는 콜백 함수를 지정해서 필터를 통과하는 모든 메시지에 대해 콜백 함수를 호출해줍니다.
콜백 함수의 리턴값이 False이면 메시지 로깅은 더 이상 처리하지 않습니다.
2)RequireDebugFalse:DEBUG=False인 경우만 핸들러가 동작하도록 합니다. 특별키 ()의 의미는 필터 객체를 생성하기 위한 클래스.
3)RequireDebugTrue:DEBUG=True인 경우만 핸들러가 동작하도록 합니다. 특별히 ()의 의미는 필터 객체를 생성하기 위한 클래스.

4.6.8 로깅 설정 - 디폴트 설정 유지
장고는 항상 로깅이 가능한 상태이므로, 로그가 피룡한 시점에 로거를 취득하고 로깅 메소드를 호출하면 됩니다.
로거를 그대로 사용하는 경우는 많지 않습니다.
왜냐하면 로거는 장고 패키지의 구성에 맞춰 사용되고 있는 것이고, 개발하고 있는 애플리케이션에 사용할 로거가 필요.
따라서 우리가 필요한 로거를 추가로 설정해주고, 이 로거를 취득하여 사용하면 됩니다.
로거를 추가하는 것은 settings.py 파일에 LOGGING 항목으로 가능합니다.
LOGGING 항목에는 새로운 로거를 추가하는 것도 가능하지만, 기존의 디폴트로 설정된 로거들을 오버라이딩하여 핸들러, 필터,
포맷터 등을 동작을 변경하는 방법을 많이 사용.
# mysite/settigns.py
//LOGGING_CONFIG는 로깅 설정에 사용하는 함수를 지정하는 항목.
//이 항목의 디폴트 값이 dictConfig이므로 생략가능.
LOGGING_CONFIG = 'logging.config.dictConfig' #생략 가능
//개발자가 로깅을 설정할 때는 LOGGING 항목을 사용합니다.
LOGGING = {
    'version':1,
    'disable_existing_loggers':False,
    'formatters':{
        //verbose 포맷터를 정의합니다.
        //verbose 모팻터는 [로그 메시지를 기록한 시간], 로그 레벨 이름, [로거이름:라인번호], 로그 메시지 순서로 출력.
        //로그 메시지를 기록한 시간에 대한 포맷은 날짜/월축약형/연도 시(24시 기준):분:초 형식으로 출력.
        'verbose':{
            'format':"[%(asctime)s] %(levelname)s [%(name)s:%(lineno)s] %(message)s",
            'datefmt':"%d/%b/%Y %H:%M:%S",
        },
    },
    'handlers':{
        //file 핸들러를 정의합니다.
        //file 핸들러는 DEBUG 및 그 이상의 메시지를 파일로 출력해주는 FileHandler 클래스를 사용합니다.
        //FileHandler 클래스에 의해 로그가 기록되는 파일 이름은 \ch5\logs\logfile입니다.
        //verbose 포맷터를 사용합니다.
        'file':{
            'level':'DEBUG',
            'class':'logging.FileHandler',
            'filename':os.path.join(BASE_DIR, 'logs', 'mysite.log'),
            'formatter':'verbose',
        },
    },
    //2개의 로거를 설정합니다.
    'loggers':{
        //디폴트로 설정되어 있는 로거인데, 핸들러와 로거 레벨을 오버라이딩하여 동작방식을 변경.
        'django':{
            'handlers':['file'],
            'level':'DEBUG',
        },
        //새롭게 정의한 로거는 DEBUG 및 그 이상의 메시지를 file 핸들러에게 보냅니다.
        //즉 로그 메시지를 파일에 기록하게 합니다.
        //로거에서 level을 정의하면 이는 핸들러에서 정의한 level을 오버라이딩합니다.
        'mysite':{
            'handlers':['file'],
            'level':'DEBUG',
        },
    },
}
로깅 설정은 장고의 디폴트 설정을 유지하면서 개발자의 로깅을 설정한 것.
장고에서 제공하는 로거들이 모두 동작하도록 설정했고, 동작하는 방식은 오버라이딩으로 변경할 수 있다.

4.6.9 로깅 설정 - 디폴트 설정 무시
파이썬의 로깅 시스템에 익숙한 독자라면 장고의 디폴트 설정을 무시하고 자신만의 로깅 방식으로 설정할 수 있다.
또는 장고의 로깅 설정이 장황해서 간단하게 설정하고자 할 때도 기존의 디폴트 설정을 무시할 수 있다.
//None이면 장고가 기본적으로 수행하는 DEFAULT_LOGGING 설정 과정을 건너 띄어 디폴트 로깅 설정이 이뤄지지 않음.
LOGGING_CONFIG = None 
//개발자가 원하는 내용으로 로거, 핸들러, 필터, 포맷터들을 정의
LOGGING = {
    (원하는 내용으로 로깅 컴포넌트들을 설정함)
}
//dictConfig() 함수를 사용하기 위해 임포트.
import logging.config
//직접 dictConfig() 함수를 호출해 사전형 방식으로 LOGGING 항목에 정의된 내용을 설정.
logging.config.dictConfig(LOGGING)